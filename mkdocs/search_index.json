{
    "docs": [
        {
            "location": "/",
            "text": "Language\n\n\n\n\nen\n\n\npt-br",
            "title": "Home"
        },
        {
            "location": "/#language",
            "text": "en  pt-br",
            "title": "Language"
        },
        {
            "location": "/licenca/",
            "text": "MIT License\n\n\nCopyright (c) 2018 The Python Packaging Authority\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.",
            "title": "Licenca"
        },
        {
            "location": "/licenca/#mit-license",
            "text": "Copyright (c) 2018 The Python Packaging Authority  Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.",
            "title": "MIT License"
        },
        {
            "location": "/de/",
            "text": "MRE\n\n\nEin Python Paket um regul\u00e4re Ausdr\u00fccke (RegEx) zu erstellen. Das Ziel von MRE ist eine einfachere Lesbarkeit von regul\u00e4ren Ausdr\u00fccken zu erm\u00f6gliche.\n\n\nInstallation von MRE\n\n\nNutze einfach pip um das MRE Paket zu installieren:\n\n\npip install mre",
            "title": "Home"
        },
        {
            "location": "/de/#mre",
            "text": "Ein Python Paket um regul\u00e4re Ausdr\u00fccke (RegEx) zu erstellen. Das Ziel von MRE ist eine einfachere Lesbarkeit von regul\u00e4ren Ausdr\u00fccken zu erm\u00f6gliche.",
            "title": "MRE"
        },
        {
            "location": "/de/#installation-von-mre",
            "text": "Nutze einfach pip um das MRE Paket zu installieren:  pip install mre",
            "title": "Installation von MRE"
        },
        {
            "location": "/de/wie-benutzt-man/",
            "text": "Klassen\n\n\n\n\nRegex\n\n\nQuantifier\n\n\nSet\n\n\nGroup\n\n\nAnchor\n\n\nHelper\n\n\nRange\n\n\n\n\n\n\n\n\nRegex\n\n\nDies ist die Elternklasse von allen anderen Klassen in diesem Paket. Der regul\u00e4re Ausdruck wird in der Variable \nself.rgx\n verarbeitet. Der Konstruktor kann eine beliebige Anzahl an parametern erhalten, welche aber alle vom Typ \nstr\n, \nint\n oder der \nRegex\n Klasse selber sein. Zum besseren Verst\u00e4ndnis:\n\n\n\n\nstr\n: wird an die Variable \nself.rgx\n angehangen;\n\n\nint\n: f\u00fchrt eine \nbackreferences\n aus\n\n\nRegex\n: f\u00fcgt den Wert von \nself.rgx\n des \u00fcbergebenen Objektes zu der Variable \nself.rgx\n des empfangenen Objektes hinzu.\n\n\n\n\nWege zur Dekleration eines \nRegex\n:\n\n\nfrom mre import Regex, Group\n\nrgx_one = Regex(\"Hello world\")  # Hello world\nrgx_two = Regex(\"Hello\", \" world\")  # Hello world\nrgx_three = Regex(\"Hello\") + \" \" + Regex(\"world\")  # Hello world\nrgx_four = Regex('<', Group('h[1-6]'), '>')  # <(h[1-6])>\nrgx_five = Regex('<', Regex.SLASH, 1, '>')  # <\\/\\1>\n\n\n\n\nKonstanten\n\n\nVerf\u00fcgbare Konstanten in der \nRegex\n Klasse:\n\n\n\n\n\n\n\n\nKonstante\n\n\nWert\n\n\n\n\n\n\n\n\n\n\nANY\n\n\n.\n\n\n\n\n\n\nDOT\n\n\n\\\\.\n\n\n\n\n\n\nDIGIT\n\n\n\\\\d\n\n\n\n\n\n\nWHITESPACE\n\n\n\\\\s\n\n\n\n\n\n\nWORD_CHARS\n\n\n\\\\w\n\n\n\n\n\n\nSLASH\n\n\n\\\\/.\n\n\n\n\n\n\nNOT_DIGIT\n\n\n\\\\D\n\n\n\n\n\n\nNOT_WHITESPACE\n\n\n\\\\S\n\n\n\n\n\n\nNOT_WORD_CHARS\n\n\n\\\\W\n\n\n\n\n\n\nZERO_OR_ONE\n\n\n?\n\n\n\n\n\n\nZERO_OR_MULTIPLE\n\n\n*\n\n\n\n\n\n\nONE_OR_MULTIPLE\n\n\n+\n\n\n\n\n\n\nHYPHEN\n\n\n\\\\-\n\n\n\n\n\n\n\n\nMethoden\n\n\nBeschreibung der Methoden und der \u00dcberladungen.\n\n\n__str__\n\n\nGibt den Wert, welchen in der variable \nself.rgx\n gespeichert ist zur\u00fcck.\n\n\nfrom mre import Regex\n\nregex = Regex(\"Hello world\")\nprint(regex)  # \"Hello world\"\n\n\n\n\n__eq__\n\n\nVergleiche sind m\u00f6glich zwischen den Typen \nstr\n und \nRegex\n:\n- \n== str\n: vergleicht \nself.rgx\n mit dem Wert der \u00fcbergebenen Variable.\n- \n== Regex\n: vergleicht \nself.rgx\n (Zugriff \u00fcber die Methode \nget\n) mit der Variable \nself.rgx\n des \u00fcbergebenen Objektes (ebenfalls mittels der Methode \nget\n).\n\n\nfrom mre import Regex\n\nregex_one = Regex(\"Hello world\")\n\nprint(regex_one == \"Hello world\")  # True\nprint(regex_one == \"Hello world!\")  # False\n\nprint(regex_one == Regex(\"Hello world\"))  # True\nprint(regex_one == Regex(\"Hello world!\"))  # False\n\n\n\n\n__iadd__\n\n\nErwarted eine Variable vom Typ \nstr\n oder \nRegex\n. F\u00fcr das bessere Verst\u00e4ndnis:\n\n\n\n\n+= str\n: f\u00fcgt der Variable \nself.rgx\n den Wert des \u00fcbergebenen Strings hinzu;\n\n\n+= Regex\n: f\u00fcgt der Variable  \nself.rgx\n den Wert der Variable \nself.rgx\n des \u00fcbergebenen Objektes (Zugriff mittels der Methode \nget\n) hinzu.\n\n\n\n\nDie \u00dcberladung \u00e4ndert direkt den Wert der Variable \nself.rgx\n. Im Falle einer Operation wie \nSet\n des Objektes, wird der Wert auf den Wert zwischen den Klammern gesetzt.\n\n\nfrom mre import Regex, Set\n\nregex = Regex(\"Hello\")\nregex += \" world\"\nprint(regex)  # \"Hello world\"\n\nregex_set = Set(\"Hello\")  # [Hello]\nregex_set += \" world\"\nprint(regex_set)  # \"[Hello world]\"\n\n\n\n\n__add__\n\n\nErwarted eine Variable vom Typ \nstr\n oder \nRegex\n.  Anders als die \u00dcberladung von \n__iadd__\n, gibt diese \u00dcberladung ein neues \nRegex\n Objekt zur\u00fcck.\n\n\n\n\n+ str\n: f\u00fcgt der Variable \nself.rgx\n (Zugriff mittels der Methode  \nget\n) den Wert des \u00fcbergebenen Strings hinzu;\n\n\n+ Regex\n: f\u00fcgt der Variable \nself.rgx\n (Zugriff mittels der Methode  \nget\n) den Wert der Variable \nself.rgx\n des \u00fcbergebenen Objektes (ebenfalls Zugriff mittels der Methode \nget\n) hinzu.\n\n\n\n\nfrom mre import Regex\n\nregex_one = Regex(\"Hello\") + \" \" + Regex(\"world\")\nregex_two = Regex(\"Hello\") + Regex(\" world\")\n\nprint(regex_one)  # \"Hello world\"\nprint(regex_two)  # \"Hello world\"\n\n\n\n\nget\n\n\nGibt den Wert, welcher in \nself.rgx\n gespeichert ist zur\u00fcck.\n\n\nfrom mre import Regex\n\nregex = Regex(\"stored value\")\nprint(regex.get())  # \"stored value\"\n\n\n\n\nquantifier\n\n\nHat folgende Parameter:\n\n\n\n\n\n\n\n\nParameter\n\n\nTyp\n\n\nStandardwert\n\n\n\n\n\n\n\n\n\n\nn\n\n\nint\n\n\n0\n\n\n\n\n\n\nm\n\n\nint\n\n\n0\n\n\n\n\n\n\nwithout_maximum\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nBenutzt um festzulegen, wie h\u00e4ufig ein regul\u00e4rer Ausdruck auftreten sollte (von \nn\n nach \nm\n). Gibt ein neues \nRegex\n Objekt zur\u00fcck.\n\n\nIn besonderen F\u00e4llen, wird ein Zeichen hinzugef\u00fcgt. Diese F\u00e4lle sind:\n\n\n\n\n\n\n\n\nn\n\n\nm\n\n\nwithout_maximum\n\n\nZeichen\n\n\nZugriff\n\n\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n-\n\n\n?\n\n\nRegex.ZERO_OR_ONE\n\n\n\n\n\n\n0\n\n\n-\n\n\nTrue\n\n\n*\n\n\nRegex.ZERO_OR_MULTIPLE\n\n\n\n\n\n\n1\n\n\n-\n\n\nTrue\n\n\n+\n\n\nRegex.ONE_OR_MULTIPLE\n\n\n\n\n\n\n\n\nZus\u00e4tzlich zu diesen besonderen F\u00e4llen, die Quantifikation kann wie folgt auftreten:\n- \n{n}\n: sollte \nn\n mal auftreten;\n- \n{n, m}\n: kann von \nn\n bis zu \nm\n mal auftreten.\n\n\nfrom mre import Regex\n\ndigits = Regex(\"[0-9]\")\n\nprint(digits.quantifier(3))  # \"[0-9]{3}\"\nprint(digits.quantifier(3, 5))  # \"[0-9]{3,5}\"\nprint(digits.quantifier(0, 1))  # \"[0-9]?\"\nprint(digits.quantifier(0, without_maximum=True))  # \"[0-9]*\"\nprint(digits.quantifier(1, without_maximum=True))  # \"[0-9]+\"\n\n\n\n\nbackreferences\n\n\nHat einen Parameter vom Typ \nint\n (\ngroup_n\n) welcher dazu benutzt wird anzuzeigen, \u00fcber welche Gruppe du eine \nbackreference\n durchf\u00fchren m\u00f6chtest. Gibt ein Objekt vom Typ \nRegex\n zur\u00fcck, welches eine \nbackreferences\n der anzuzeigenden Gruppe durchf\u00fchrt\n\n\nEin alternativer Weg diese Funktion aufzurufen ist dem Konstruktor einen \nint\n bereitzustellen.\n\n\nfrom mre import Regex\n\nregex_one = Regex().backreferences(1)\nregex_two = Regex(2)\n\nprint(regex_one)  # \"\\1\"\nprint(regex_two)  # \"\\2\"\n\n\n\n\nQuantifier\n\n\nDiese Klasse stellt eine Alternative zum Aufruf \nRegex.quantifier\n dar. Der Konstruktor hat 4 Parameter:\n\n\n\n\n\n\n\n\nParameter\n\n\nTyp\n\n\ndStandardwert\n\n\n\n\n\n\n\n\n\n\nregex\n\n\nstr\n, \nint\n, \nRegex\n\n\n\"\"\n\n\n\n\n\n\nn\n\n\nint\n\n\n0\n\n\n\n\n\n\nm\n\n\nint\n\n\n0\n\n\n\n\n\n\nwithout_maximum\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nDer erste Parameter verweist auf den regul\u00e4ren Ausdruck, welcher erstellt werden soll. Die anderen drei dienen dem Aufruf der Methode \nRegex.quantifier\n.\n\n\nfrom mre import Regex, Quantifier\n\ndigits_one = Regex(\"[0-9]\").quantifier(3, 5)\ndigits_two = Quantifier(\"[0-9]\", 3, 5)\n\nprint(digits_one)  # \"[0-9]{3,5}\"\nprint(digits_two)  # \"[0-9]{3,5}\"\n\n\n\n\nSet\n\n\nDiese Klasse repr\u00e4sentiert ein Set in RegEx. Der Konstruktor ist identisch zu \nRegex\n.\n\n\nfrom mre import Set\n\nregex_set = Set(\"0-9\")\n\nprint(regex_set)  # \"[0-9]\"\nprint(regex_set.quantifier(3))  # \"[0-9]{3}\"\n\n\n\n\nMethoden\n\n\nDiese Klasse erbt die Methoden der Klasse \nRegex\n und \u00fcberschreibt folgende:\n\n\nget\n\n\nGibt den Wert welcher in \nself.rgx\n gespeichert wird zur\u00fcck, aber in Klammern.\n\n\nfrom mre import Set\n\nregex_set = Set(\"0-9\")\nprint(regex_set.get())  # \"[0-9]\"\n\n\n\n\nquantifier\n\n\nGibt ein neues \nRegex\n Objekt zur\u00fcck mit einem Quantifier f\u00fcr das Set.\n\n\nfrom mre import Set\n\nregex_set = Set(\"0-9\")\n\nprint(regex_set)  # \"[0-9]\"\nprint(regex_set.quantifier(3))  # \"[0-9]{3}\"\n\nprint(type(regex_set))  # <class 'mre.Set.Set'>\nprint(type(regex_set.quantifier(3)))  # <class 'mre.Regex.Regex'>\n\n\n\n\nGroup\n\n\nDiese Klasse repr\u00e4sentiert eine Gruppe in RegEx. Der Konstruktor hat zwei Parameter:\n\n\n\n\n\n\n\n\nParameter\n\n\nTyp\n\n\ndStandardwert\n\n\n\n\n\n\n\n\n\n\nregex\n\n\nstr\n, \nint\n, \nRegex\n\n\n\"\"\n\n\n\n\n\n\nnon_capturing\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nWenn der Ausdruck f\u00fcr \nnon_capturing\n \nTrue\n ist, das Zeichen, welches die \nRegEx Engine\n anzeigt wird der Non-Captured-Gruppe hinzugef\u00fcgt (\n?:\n).\n\n\nfrom mre import Group\n\nregex_group_one = Group('<h1>') + Group('[\\w\\s]+') + Group('</h1>')\nregex_group_two = Group('<h1>', True) + Group('[\\w\\s]+') + Group('</h1>', True)\n\nprint(regex_group_one)  # (<h1>)([\\w\\s]+)(</h1>)\nprint(regex_group_two)  # (?:<h1>)([\\w\\s]+)(?:</h1>)\n\n\n\n\nMethoden\n\n\nDiese Klasse erbt die Methoden der Klasse \nRegex\n und \u00fcberschreibt folgende:\n\n\nget\n\n\nGibt den Wert welcher in \nself.rgx\n gespeichert wird zur\u00fcck, aber in runden Klammern.\n\n\nfrom mre import Group\n\nregex_group_one = Group(\"<h1>\")\nregex_group_two = Group(\"</h1>\", True)\n\nprint(regex_group_one.get())  # \"(<h1>)\"\nprint(regex_group_two.get())  # \"(?:</h1>)\"\n\n\n\n\nquantifier\n\n\nGibt ein neues \nRegex\n Objekt zur\u00fcck mit einem Quantifier f\u00fcr das Set.\n\n\nfrom mre import Group\n\nregex_group = Group(\"<h1>\")\n\nprint(regex_group)  # \"(<h1>)\"\nprint(regex_group.quantifier(3))  # \"(<h1>){3}\"\n\nprint(type(regex_group))  # <class 'mre.Group.Group'>\nprint(type(regex_group.quantifier(3)))  # <class 'mre.Regex.Regex'>\n\n\n\n\nAnchor\n\n\nDiese Klasse repr\u00e4sentiert ein verankerten regul\u00e4ren Ausdruck (Der RegEx muss beginnen und enden wie definiert). Der Konstruktor hat zwei Parameter:\n\n\n\n\n\n\n\n\nParameter\n\n\nTyp\n\n\nStandardwert\n\n\n\n\n\n\n\n\n\n\nregex\n\n\nstr\n, \nint\n, \nRegex\n\n\n\"\"\n\n\n\n\n\n\nnegate\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nWenn das Argument f\u00fcr \nnegate\n \nTrue\n ist, wird das Inverse Pattern Zeichen hinzugef\u00fcgt, zum Beispiel darf der RegEx nicht wie definiert beginnen und enden.\n\n\nfrom mre import Anchor\n\nregex_anchor_one = Anchor(\"\\\\d{4}-\\\\w+.txt\")\nregex_anchor_two = Anchor(\"\\\\d{4}-\\\\w+.txt\", True)\n\nprint(regex_anchor_one)  # \"^\\d{4}-\\w+.txt$\"\nprint(regex_anchor_two)  # \"\\b\\d{4}-\\w+.txt\\B\"\n\n\n\n\nMethoden\n\n\nDiese Klasse erbt die Methoden der Klasse \nRegex\n und \u00fcberschreibt folgende:\n\n\nget\n\n\nGibt den Wert welcher in \nself.rgx\n gespeichert wird zur\u00fcck, aber verankert.\n\n\nfrom mre import Anchor\n\nregex_anchor_one = Anchor(\"<h1>Hello world<\\/h1>\")\nregex_anchor_two = Anchor(\"<h1>Hello world<\\/h1>\", True)\n\nprint(regex_anchor_one.get())  # \"^<h1>Hello world</h1>$\"\nprint(regex_anchor_two.get())  # \"\\b<h1>Hello world</h1>\\B\"\n\n\n\n\nhelper.Range\n\n\nDiese Klasse dient dazu zu bei der Erstellung eines RegEx zu helfen, welches die die Zeichenklasse in Form einer \nrange\n darstellt. Der Konstruktor hat zwei Parameter:\n\n\n\n\n\n\n\n\nParameter\n\n\nTyp\n\n\nStandardwert\n\n\n\n\n\n\n\n\n\n\nminimum\n\n\nstr\n, \nint\n\n\n0\n\n\n\n\n\n\nmaximum\n\n\nstr\n, \nint\n\n\n\"z\"\n\n\n\n\n\n\n\n\nIdealerweise solltest du die Klasse zusammen mit einem \nSet\n nutzen. In einem \nSet\n hat der Bindestrich einen \"magischen\" Wert, welcher erlaubt eine Spanne zuzuweisen. Au\u00dferhalb eines Sets hat der Bindestrich nur den Bindesstrichwert. Wenn du also kleingeschriebene Buchstaben m\u00f6chtest, solltest du \n[a-z]\n statt \na-z\n nutzen. \na-z\n zeigt nur an, dass du die Zeichen \na\n, \n-\n und \nz\n m\u00f6chtest.\n\n\nfrom mre.helper import Range\n\n# all digits\ndigits = Range(0, 9)\n# all letters\nletters = Range('A', 'z')\n\nprint(digits)  # \"0-9\"\nprint(letters)  # \"A-z\"\n\n\n\n\nMethoden\n\n\nDiese Klasse erbt die Methoden der Klasse \nRegex\n und hat ihre eigenen Methoden.\n\n\ndigits\n\n\nHat zwei Parameter:\n\n\n\n\n\n\n\n\nParameter\n\n\nTyp\n\n\nStandardwert\n\n\n\n\n\n\n\n\n\n\nminimum\n\n\nint\n\n\n0\n\n\n\n\n\n\nmaximum\n\n\nint\n\n\n9\n\n\n\n\n\n\n\n\nGibt eine Spanne(\nrange\n) zur\u00fcck, welche durch die Ziffern zwischen \nminimum\n und \nmaximum\n definiert ist.\n\n\nfrom mre.helper import Range\n\nregex_range_one = Range(0, 9)\nregex_range_two = Range().digits()\nregex_range_three = Range(0, 6)\nregex_range_four = Range().digits(0, 6)\n\nprint(regex_range_one)  # \"0-9\"\nprint(regex_range_two)  # \"0-9\"\nprint(regex_range_three)  # \"0-6\"\nprint(regex_range_four)  # \"0-6\"\n\n\n\n\nletters\n\n\nHat vier Parameter:\n\n\n\n\n\n\n\n\nParameter\n\n\nTyp\n\n\nStandard Wert\n\n\n\n\n\n\n\n\n\n\nminimum\n\n\nchr\n\n\nA\n\n\n\n\n\n\nmaximum\n\n\nchr\n\n\nz\n\n\n\n\n\n\nuppercase\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\nlowercase\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nGibt eine Spanne (\nrange\n) zr\u00fcck, welche den Zwichen zwischen \nminimum\n und \nmaximum\n entspricht.\n\n\nfrom mre.helper import Range\n\n# all letters\nregex_range_one = Range('A', 'z')\nregex_range_two = Range().letters()\nregex_range_three = Range().letters('A', 'z')\nregex_range_four = Range().letters(uppercase=True, lowercase=True)\n# all capital letters\nregex_range_five = Range().letters(uppercase=True)\n# all lowercase letters\nregex_range_six = Range().letters(lowercase=True)\n\nprint(regex_range_one)  # \"A-z\"\nprint(regex_range_two)  # \"A-z\"\nprint(regex_range_three)  # \"A-z\"\nprint(regex_range_four)  # \"A-z\"\nprint(regex_range_five)  # \"A-Z\"\nprint(regex_range_six)  # \"a-z\"\n\n\n\n\nBeispiele\n\n\nEs gibt zwei M\u00f6glichkeiten zum Erstellen eines RegEx f\u00fcr \nCEP\n (Brasilianische Postleitzahl) (\n[0-9]{5}-?[0-9]{3}\n):\n\n\nfrom mre import Regex, Set\n\n# all digits\ndigits = Set(Regex(\"0-9\"))\n\nrgx_cep = Regex(\n    digits.quantifier(5),\n    Regex(\"-\").quantifier(0, 1),\n    digits.quantifier(3),\n)\n\n\n\n\nfrom mre import Regex, Quantifier, Set\nfrom mre.helper import Range\n\n# all digits [0-9]\ndigits = Set(Range().digits())\n# the hyphen may appear zero or one times\nhyphen = Quantifier(\"-\", 0, 1)\n\nrgx_cep = Regex(\n    digits.quantifier(5), hyphen,\n    digits.quantifier(3),\n)\n\n\n\n\nRegEx f\u00fcr eine \nCPF\n (Brasilianische Steuernummer) (\n[0-9]{3}.?[0-9]{3}.?[0-9]{3}-?[0-9]{2}\n):\n\n\nfrom mre import Regex, Set\nfrom mre.helper import Range\n\n# all digits\nall_digits = Set(Range(0, 9))\n# the dot may appear zero or one times\ndot = Regex(Regex.DOT).quantifier(0, 1)\n# the hyphen may appear zero or one times\nhyphen = Regex('-').quantifier(0, 1)\n\nrgx_cpf = Regex(\n    all_digits.quantifier(3), dot,\n    all_digits.quantifier(3), dot,\n    all_digits.quantifier(3), hyphen,\n    all_digits.quantifier(2),\n)\n\n\n\n\nRegEx f\u00fcr eine \nCNPJ\n (ID in der brasilianischen Datenbank f\u00fcr rechtliche Personen ) (\n\\d{2}\\.?\\d{3}\\.?\\d{3}\\/?\\d{4}\\-?\\d{2}\n):\n\n\nfrom mre import Regex, Quantifier\n\n# all digits\ndigits = Regex(Regex.DIGIT)\n# the dot may appear zero or one times\ndot = Regex(Regex.DOT).quantifier(0, 1)\n# the slash may appear zero or one times\nslash = Regex(Regex.SLASH).quantifier(0, 1)\n# the hyphen may appear zero or one times\nhyphen = Quantifier(\"-\", 0, 1)\n\nrgx_cnpj = Regex(\n    digits.quantifier(2), dot,\n    digits.quantifier(3), dot,\n    digits.quantifier(3), slash,\n    digits.quantifier(4), hyphen,\n    digits.quantifier(2),\n)",
            "title": "Wie benutzt man"
        },
        {
            "location": "/de/wie-benutzt-man/#klassen",
            "text": "Regex  Quantifier  Set  Group  Anchor  Helper  Range",
            "title": "Klassen"
        },
        {
            "location": "/de/wie-benutzt-man/#regex",
            "text": "Dies ist die Elternklasse von allen anderen Klassen in diesem Paket. Der regul\u00e4re Ausdruck wird in der Variable  self.rgx  verarbeitet. Der Konstruktor kann eine beliebige Anzahl an parametern erhalten, welche aber alle vom Typ  str ,  int  oder der  Regex  Klasse selber sein. Zum besseren Verst\u00e4ndnis:   str : wird an die Variable  self.rgx  angehangen;  int : f\u00fchrt eine  backreferences  aus  Regex : f\u00fcgt den Wert von  self.rgx  des \u00fcbergebenen Objektes zu der Variable  self.rgx  des empfangenen Objektes hinzu.   Wege zur Dekleration eines  Regex :  from mre import Regex, Group\n\nrgx_one = Regex(\"Hello world\")  # Hello world\nrgx_two = Regex(\"Hello\", \" world\")  # Hello world\nrgx_three = Regex(\"Hello\") + \" \" + Regex(\"world\")  # Hello world\nrgx_four = Regex('<', Group('h[1-6]'), '>')  # <(h[1-6])>\nrgx_five = Regex('<', Regex.SLASH, 1, '>')  # <\\/\\1>",
            "title": "Regex"
        },
        {
            "location": "/de/wie-benutzt-man/#konstanten",
            "text": "Verf\u00fcgbare Konstanten in der  Regex  Klasse:     Konstante  Wert      ANY  .    DOT  \\\\.    DIGIT  \\\\d    WHITESPACE  \\\\s    WORD_CHARS  \\\\w    SLASH  \\\\/.    NOT_DIGIT  \\\\D    NOT_WHITESPACE  \\\\S    NOT_WORD_CHARS  \\\\W    ZERO_OR_ONE  ?    ZERO_OR_MULTIPLE  *    ONE_OR_MULTIPLE  +    HYPHEN  \\\\-",
            "title": "Konstanten"
        },
        {
            "location": "/de/wie-benutzt-man/#methoden",
            "text": "Beschreibung der Methoden und der \u00dcberladungen.",
            "title": "Methoden"
        },
        {
            "location": "/de/wie-benutzt-man/#9595str9595",
            "text": "Gibt den Wert, welchen in der variable  self.rgx  gespeichert ist zur\u00fcck.  from mre import Regex\n\nregex = Regex(\"Hello world\")\nprint(regex)  # \"Hello world\"",
            "title": "__str__"
        },
        {
            "location": "/de/wie-benutzt-man/#9595eq9595",
            "text": "Vergleiche sind m\u00f6glich zwischen den Typen  str  und  Regex :\n-  == str : vergleicht  self.rgx  mit dem Wert der \u00fcbergebenen Variable.\n-  == Regex : vergleicht  self.rgx  (Zugriff \u00fcber die Methode  get ) mit der Variable  self.rgx  des \u00fcbergebenen Objektes (ebenfalls mittels der Methode  get ).  from mre import Regex\n\nregex_one = Regex(\"Hello world\")\n\nprint(regex_one == \"Hello world\")  # True\nprint(regex_one == \"Hello world!\")  # False\n\nprint(regex_one == Regex(\"Hello world\"))  # True\nprint(regex_one == Regex(\"Hello world!\"))  # False",
            "title": "__eq__"
        },
        {
            "location": "/de/wie-benutzt-man/#9595iadd9595",
            "text": "Erwarted eine Variable vom Typ  str  oder  Regex . F\u00fcr das bessere Verst\u00e4ndnis:   += str : f\u00fcgt der Variable  self.rgx  den Wert des \u00fcbergebenen Strings hinzu;  += Regex : f\u00fcgt der Variable   self.rgx  den Wert der Variable  self.rgx  des \u00fcbergebenen Objektes (Zugriff mittels der Methode  get ) hinzu.   Die \u00dcberladung \u00e4ndert direkt den Wert der Variable  self.rgx . Im Falle einer Operation wie  Set  des Objektes, wird der Wert auf den Wert zwischen den Klammern gesetzt.  from mre import Regex, Set\n\nregex = Regex(\"Hello\")\nregex += \" world\"\nprint(regex)  # \"Hello world\"\n\nregex_set = Set(\"Hello\")  # [Hello]\nregex_set += \" world\"\nprint(regex_set)  # \"[Hello world]\"",
            "title": "__iadd__"
        },
        {
            "location": "/de/wie-benutzt-man/#9595add9595",
            "text": "Erwarted eine Variable vom Typ  str  oder  Regex .  Anders als die \u00dcberladung von  __iadd__ , gibt diese \u00dcberladung ein neues  Regex  Objekt zur\u00fcck.   + str : f\u00fcgt der Variable  self.rgx  (Zugriff mittels der Methode   get ) den Wert des \u00fcbergebenen Strings hinzu;  + Regex : f\u00fcgt der Variable  self.rgx  (Zugriff mittels der Methode   get ) den Wert der Variable  self.rgx  des \u00fcbergebenen Objektes (ebenfalls Zugriff mittels der Methode  get ) hinzu.   from mre import Regex\n\nregex_one = Regex(\"Hello\") + \" \" + Regex(\"world\")\nregex_two = Regex(\"Hello\") + Regex(\" world\")\n\nprint(regex_one)  # \"Hello world\"\nprint(regex_two)  # \"Hello world\"",
            "title": "__add__"
        },
        {
            "location": "/de/wie-benutzt-man/#get",
            "text": "Gibt den Wert, welcher in  self.rgx  gespeichert ist zur\u00fcck.  from mre import Regex\n\nregex = Regex(\"stored value\")\nprint(regex.get())  # \"stored value\"",
            "title": "get"
        },
        {
            "location": "/de/wie-benutzt-man/#quantifier",
            "text": "Hat folgende Parameter:     Parameter  Typ  Standardwert      n  int  0    m  int  0    without_maximum  bool  False     Benutzt um festzulegen, wie h\u00e4ufig ein regul\u00e4rer Ausdruck auftreten sollte (von  n  nach  m ). Gibt ein neues  Regex  Objekt zur\u00fcck.  In besonderen F\u00e4llen, wird ein Zeichen hinzugef\u00fcgt. Diese F\u00e4lle sind:     n  m  without_maximum  Zeichen  Zugriff      0  1  -  ?  Regex.ZERO_OR_ONE    0  -  True  *  Regex.ZERO_OR_MULTIPLE    1  -  True  +  Regex.ONE_OR_MULTIPLE     Zus\u00e4tzlich zu diesen besonderen F\u00e4llen, die Quantifikation kann wie folgt auftreten:\n-  {n} : sollte  n  mal auftreten;\n-  {n, m} : kann von  n  bis zu  m  mal auftreten.  from mre import Regex\n\ndigits = Regex(\"[0-9]\")\n\nprint(digits.quantifier(3))  # \"[0-9]{3}\"\nprint(digits.quantifier(3, 5))  # \"[0-9]{3,5}\"\nprint(digits.quantifier(0, 1))  # \"[0-9]?\"\nprint(digits.quantifier(0, without_maximum=True))  # \"[0-9]*\"\nprint(digits.quantifier(1, without_maximum=True))  # \"[0-9]+\"",
            "title": "quantifier"
        },
        {
            "location": "/de/wie-benutzt-man/#backreferences",
            "text": "Hat einen Parameter vom Typ  int  ( group_n ) welcher dazu benutzt wird anzuzeigen, \u00fcber welche Gruppe du eine  backreference  durchf\u00fchren m\u00f6chtest. Gibt ein Objekt vom Typ  Regex  zur\u00fcck, welches eine  backreferences  der anzuzeigenden Gruppe durchf\u00fchrt  Ein alternativer Weg diese Funktion aufzurufen ist dem Konstruktor einen  int  bereitzustellen.  from mre import Regex\n\nregex_one = Regex().backreferences(1)\nregex_two = Regex(2)\n\nprint(regex_one)  # \"\\1\"\nprint(regex_two)  # \"\\2\"",
            "title": "backreferences"
        },
        {
            "location": "/de/wie-benutzt-man/#quantifier_1",
            "text": "Diese Klasse stellt eine Alternative zum Aufruf  Regex.quantifier  dar. Der Konstruktor hat 4 Parameter:     Parameter  Typ  dStandardwert      regex  str ,  int ,  Regex  \"\"    n  int  0    m  int  0    without_maximum  bool  False     Der erste Parameter verweist auf den regul\u00e4ren Ausdruck, welcher erstellt werden soll. Die anderen drei dienen dem Aufruf der Methode  Regex.quantifier .  from mre import Regex, Quantifier\n\ndigits_one = Regex(\"[0-9]\").quantifier(3, 5)\ndigits_two = Quantifier(\"[0-9]\", 3, 5)\n\nprint(digits_one)  # \"[0-9]{3,5}\"\nprint(digits_two)  # \"[0-9]{3,5}\"",
            "title": "Quantifier"
        },
        {
            "location": "/de/wie-benutzt-man/#set",
            "text": "Diese Klasse repr\u00e4sentiert ein Set in RegEx. Der Konstruktor ist identisch zu  Regex .  from mre import Set\n\nregex_set = Set(\"0-9\")\n\nprint(regex_set)  # \"[0-9]\"\nprint(regex_set.quantifier(3))  # \"[0-9]{3}\"",
            "title": "Set"
        },
        {
            "location": "/de/wie-benutzt-man/#methoden_1",
            "text": "Diese Klasse erbt die Methoden der Klasse  Regex  und \u00fcberschreibt folgende:",
            "title": "Methoden"
        },
        {
            "location": "/de/wie-benutzt-man/#get_1",
            "text": "Gibt den Wert welcher in  self.rgx  gespeichert wird zur\u00fcck, aber in Klammern.  from mre import Set\n\nregex_set = Set(\"0-9\")\nprint(regex_set.get())  # \"[0-9]\"",
            "title": "get"
        },
        {
            "location": "/de/wie-benutzt-man/#quantifier_2",
            "text": "Gibt ein neues  Regex  Objekt zur\u00fcck mit einem Quantifier f\u00fcr das Set.  from mre import Set\n\nregex_set = Set(\"0-9\")\n\nprint(regex_set)  # \"[0-9]\"\nprint(regex_set.quantifier(3))  # \"[0-9]{3}\"\n\nprint(type(regex_set))  # <class 'mre.Set.Set'>\nprint(type(regex_set.quantifier(3)))  # <class 'mre.Regex.Regex'>",
            "title": "quantifier"
        },
        {
            "location": "/de/wie-benutzt-man/#group",
            "text": "Diese Klasse repr\u00e4sentiert eine Gruppe in RegEx. Der Konstruktor hat zwei Parameter:     Parameter  Typ  dStandardwert      regex  str ,  int ,  Regex  \"\"    non_capturing  bool  False     Wenn der Ausdruck f\u00fcr  non_capturing   True  ist, das Zeichen, welches die  RegEx Engine  anzeigt wird der Non-Captured-Gruppe hinzugef\u00fcgt ( ?: ).  from mre import Group\n\nregex_group_one = Group('<h1>') + Group('[\\w\\s]+') + Group('</h1>')\nregex_group_two = Group('<h1>', True) + Group('[\\w\\s]+') + Group('</h1>', True)\n\nprint(regex_group_one)  # (<h1>)([\\w\\s]+)(</h1>)\nprint(regex_group_two)  # (?:<h1>)([\\w\\s]+)(?:</h1>)",
            "title": "Group"
        },
        {
            "location": "/de/wie-benutzt-man/#methoden_2",
            "text": "Diese Klasse erbt die Methoden der Klasse  Regex  und \u00fcberschreibt folgende:",
            "title": "Methoden"
        },
        {
            "location": "/de/wie-benutzt-man/#get_2",
            "text": "Gibt den Wert welcher in  self.rgx  gespeichert wird zur\u00fcck, aber in runden Klammern.  from mre import Group\n\nregex_group_one = Group(\"<h1>\")\nregex_group_two = Group(\"</h1>\", True)\n\nprint(regex_group_one.get())  # \"(<h1>)\"\nprint(regex_group_two.get())  # \"(?:</h1>)\"",
            "title": "get"
        },
        {
            "location": "/de/wie-benutzt-man/#quantifier_3",
            "text": "Gibt ein neues  Regex  Objekt zur\u00fcck mit einem Quantifier f\u00fcr das Set.  from mre import Group\n\nregex_group = Group(\"<h1>\")\n\nprint(regex_group)  # \"(<h1>)\"\nprint(regex_group.quantifier(3))  # \"(<h1>){3}\"\n\nprint(type(regex_group))  # <class 'mre.Group.Group'>\nprint(type(regex_group.quantifier(3)))  # <class 'mre.Regex.Regex'>",
            "title": "quantifier"
        },
        {
            "location": "/de/wie-benutzt-man/#anchor",
            "text": "Diese Klasse repr\u00e4sentiert ein verankerten regul\u00e4ren Ausdruck (Der RegEx muss beginnen und enden wie definiert). Der Konstruktor hat zwei Parameter:     Parameter  Typ  Standardwert      regex  str ,  int ,  Regex  \"\"    negate  bool  False     Wenn das Argument f\u00fcr  negate   True  ist, wird das Inverse Pattern Zeichen hinzugef\u00fcgt, zum Beispiel darf der RegEx nicht wie definiert beginnen und enden.  from mre import Anchor\n\nregex_anchor_one = Anchor(\"\\\\d{4}-\\\\w+.txt\")\nregex_anchor_two = Anchor(\"\\\\d{4}-\\\\w+.txt\", True)\n\nprint(regex_anchor_one)  # \"^\\d{4}-\\w+.txt$\"\nprint(regex_anchor_two)  # \"\\b\\d{4}-\\w+.txt\\B\"",
            "title": "Anchor"
        },
        {
            "location": "/de/wie-benutzt-man/#methoden_3",
            "text": "Diese Klasse erbt die Methoden der Klasse  Regex  und \u00fcberschreibt folgende:",
            "title": "Methoden"
        },
        {
            "location": "/de/wie-benutzt-man/#get_3",
            "text": "Gibt den Wert welcher in  self.rgx  gespeichert wird zur\u00fcck, aber verankert.  from mre import Anchor\n\nregex_anchor_one = Anchor(\"<h1>Hello world<\\/h1>\")\nregex_anchor_two = Anchor(\"<h1>Hello world<\\/h1>\", True)\n\nprint(regex_anchor_one.get())  # \"^<h1>Hello world</h1>$\"\nprint(regex_anchor_two.get())  # \"\\b<h1>Hello world</h1>\\B\"",
            "title": "get"
        },
        {
            "location": "/de/wie-benutzt-man/#helperrange",
            "text": "Diese Klasse dient dazu zu bei der Erstellung eines RegEx zu helfen, welches die die Zeichenklasse in Form einer  range  darstellt. Der Konstruktor hat zwei Parameter:     Parameter  Typ  Standardwert      minimum  str ,  int  0    maximum  str ,  int  \"z\"     Idealerweise solltest du die Klasse zusammen mit einem  Set  nutzen. In einem  Set  hat der Bindestrich einen \"magischen\" Wert, welcher erlaubt eine Spanne zuzuweisen. Au\u00dferhalb eines Sets hat der Bindestrich nur den Bindesstrichwert. Wenn du also kleingeschriebene Buchstaben m\u00f6chtest, solltest du  [a-z]  statt  a-z  nutzen.  a-z  zeigt nur an, dass du die Zeichen  a ,  -  und  z  m\u00f6chtest.  from mre.helper import Range\n\n# all digits\ndigits = Range(0, 9)\n# all letters\nletters = Range('A', 'z')\n\nprint(digits)  # \"0-9\"\nprint(letters)  # \"A-z\"",
            "title": "helper.Range"
        },
        {
            "location": "/de/wie-benutzt-man/#methoden_4",
            "text": "Diese Klasse erbt die Methoden der Klasse  Regex  und hat ihre eigenen Methoden.",
            "title": "Methoden"
        },
        {
            "location": "/de/wie-benutzt-man/#digits",
            "text": "Hat zwei Parameter:     Parameter  Typ  Standardwert      minimum  int  0    maximum  int  9     Gibt eine Spanne( range ) zur\u00fcck, welche durch die Ziffern zwischen  minimum  und  maximum  definiert ist.  from mre.helper import Range\n\nregex_range_one = Range(0, 9)\nregex_range_two = Range().digits()\nregex_range_three = Range(0, 6)\nregex_range_four = Range().digits(0, 6)\n\nprint(regex_range_one)  # \"0-9\"\nprint(regex_range_two)  # \"0-9\"\nprint(regex_range_three)  # \"0-6\"\nprint(regex_range_four)  # \"0-6\"",
            "title": "digits"
        },
        {
            "location": "/de/wie-benutzt-man/#letters",
            "text": "Hat vier Parameter:     Parameter  Typ  Standard Wert      minimum  chr  A    maximum  chr  z    uppercase  bool  False    lowercase  bool  False     Gibt eine Spanne ( range ) zr\u00fcck, welche den Zwichen zwischen  minimum  und  maximum  entspricht.  from mre.helper import Range\n\n# all letters\nregex_range_one = Range('A', 'z')\nregex_range_two = Range().letters()\nregex_range_three = Range().letters('A', 'z')\nregex_range_four = Range().letters(uppercase=True, lowercase=True)\n# all capital letters\nregex_range_five = Range().letters(uppercase=True)\n# all lowercase letters\nregex_range_six = Range().letters(lowercase=True)\n\nprint(regex_range_one)  # \"A-z\"\nprint(regex_range_two)  # \"A-z\"\nprint(regex_range_three)  # \"A-z\"\nprint(regex_range_four)  # \"A-z\"\nprint(regex_range_five)  # \"A-Z\"\nprint(regex_range_six)  # \"a-z\"",
            "title": "letters"
        },
        {
            "location": "/de/wie-benutzt-man/#beispiele",
            "text": "Es gibt zwei M\u00f6glichkeiten zum Erstellen eines RegEx f\u00fcr  CEP  (Brasilianische Postleitzahl) ( [0-9]{5}-?[0-9]{3} ):  from mre import Regex, Set\n\n# all digits\ndigits = Set(Regex(\"0-9\"))\n\nrgx_cep = Regex(\n    digits.quantifier(5),\n    Regex(\"-\").quantifier(0, 1),\n    digits.quantifier(3),\n)  from mre import Regex, Quantifier, Set\nfrom mre.helper import Range\n\n# all digits [0-9]\ndigits = Set(Range().digits())\n# the hyphen may appear zero or one times\nhyphen = Quantifier(\"-\", 0, 1)\n\nrgx_cep = Regex(\n    digits.quantifier(5), hyphen,\n    digits.quantifier(3),\n)  RegEx f\u00fcr eine  CPF  (Brasilianische Steuernummer) ( [0-9]{3}.?[0-9]{3}.?[0-9]{3}-?[0-9]{2} ):  from mre import Regex, Set\nfrom mre.helper import Range\n\n# all digits\nall_digits = Set(Range(0, 9))\n# the dot may appear zero or one times\ndot = Regex(Regex.DOT).quantifier(0, 1)\n# the hyphen may appear zero or one times\nhyphen = Regex('-').quantifier(0, 1)\n\nrgx_cpf = Regex(\n    all_digits.quantifier(3), dot,\n    all_digits.quantifier(3), dot,\n    all_digits.quantifier(3), hyphen,\n    all_digits.quantifier(2),\n)  RegEx f\u00fcr eine  CNPJ  (ID in der brasilianischen Datenbank f\u00fcr rechtliche Personen ) ( \\d{2}\\.?\\d{3}\\.?\\d{3}\\/?\\d{4}\\-?\\d{2} ):  from mre import Regex, Quantifier\n\n# all digits\ndigits = Regex(Regex.DIGIT)\n# the dot may appear zero or one times\ndot = Regex(Regex.DOT).quantifier(0, 1)\n# the slash may appear zero or one times\nslash = Regex(Regex.SLASH).quantifier(0, 1)\n# the hyphen may appear zero or one times\nhyphen = Quantifier(\"-\", 0, 1)\n\nrgx_cnpj = Regex(\n    digits.quantifier(2), dot,\n    digits.quantifier(3), dot,\n    digits.quantifier(3), slash,\n    digits.quantifier(4), hyphen,\n    digits.quantifier(2),\n)",
            "title": "Beispiele"
        },
        {
            "location": "/en/how-to-use/",
            "text": "Classes\n\n\n\n\nRegex\n\n\nQuantifier\n\n\nSet\n\n\nGroup\n\n\nAnchor\n\n\nHelper\n\n\nRange\n\n\n\n\n\n\n\n\nRegex\n\n\nThis is the parent class of all other classes in this package, the RegEx is being handled in variable \nself.rgx\n. Your constructor can receive any number of inputs, but they require the following types: \nstr\n, \nint\n and the \nRegex\n class itself. For better understanding:\n\n\n\n\nstr\n: concatenates to variable \nself.rgx\n;\n\n\nint\n: performs \nbackreferences\n;\n\n\nRegex\n: concatenates the value of \nself.rgx\n of the passed object to variable \nself.rgx\n of the receiving object.\n\n\n\n\nWays to declare a \nRegex\n:\n\n\nfrom mre import Regex, Group\n\nrgx_one = Regex(\"Hello world\")  # Hello world\nrgx_two = Regex(\"Hello\", \" world\")  # Hello world\nrgx_three = Regex(\"Hello\") + \" \" + Regex(\"world\")  # Hello world\nrgx_four = Regex('<', Group('h[1-6]'), '>')  # <(h[1-6])>\nrgx_five = Regex('<', Regex.SLASH, 1, '>')  # <\\/\\1>\n\n\n\n\nConstants\n\n\nConstants available in class \nRegex\n:\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nANY\n\n\n.\n\n\n\n\n\n\nDOT\n\n\n\\\\.\n\n\n\n\n\n\nDIGIT\n\n\n\\\\d\n\n\n\n\n\n\nWHITESPACE\n\n\n\\\\s\n\n\n\n\n\n\nWORD_CHARS\n\n\n\\\\w\n\n\n\n\n\n\nSLASH\n\n\n\\\\/.\n\n\n\n\n\n\nNOT_DIGIT\n\n\n\\\\D\n\n\n\n\n\n\nNOT_WHITESPACE\n\n\n\\\\S\n\n\n\n\n\n\nNOT_WORD_CHARS\n\n\n\\\\W\n\n\n\n\n\n\nZERO_OR_ONE\n\n\n?\n\n\n\n\n\n\nZERO_OR_MULTIPLE\n\n\n*\n\n\n\n\n\n\nONE_OR_MULTIPLE\n\n\n+\n\n\n\n\n\n\nHYPHEN\n\n\n\\\\-\n\n\n\n\n\n\n\n\nMethods\n\n\nDescriptions of methods and overloads.\n\n\n__str__\n\n\nReturns the value stored in \nself.rgx\n.\n\n\nfrom mre import Regex\n\nregex = Regex(\"Hello world\")\nprint(regex)  # \"Hello world\"\n\n\n\n\n__eq__\n\n\nComparisons are possible with \nstr\n and \nRegex\n type:\n- \n== str\n: compares \nself.rgx\n to the value of the passed variable;\n- \n== Regex\n: compares \nself.rgx\n (accessed via method \nget\n) to the value of \nself.rgx\n of the passed object (also accessed via method \nget\n).\n\n\nfrom mre import Regex\n\nregex_one = Regex(\"Hello world\")\n\nprint(regex_one == \"Hello world\")  # True\nprint(regex_one == \"Hello world!\")  # False\n\nprint(regex_one == Regex(\"Hello world\"))  # True\nprint(regex_one == Regex(\"Hello world!\"))  # False\n\n\n\n\n__iadd__\n\n\nExpects variables of type \nstr\n and \nRegex\n. For better understanding:\n\n\n\n\n+= str\n: concatenates \nself.rgx\n with the value of the passed variable;\n\n\n+= Regex\n: concatenates \nself.rgx\n with the value of variable \nself.rgx\n of the passed object (accessed via method \nget\n).\n\n\n\n\nThe overload directly changes the value of \nself.rgx\n. In case of operations like \nSet\n of an object, it will change to the value between to brackets.\n\n\nfrom mre import Regex, Set\n\nregex = Regex(\"Hello\")\nregex += \" world\"\nprint(regex)  # \"Hello world\"\n\nregex_set = Set(\"Hello\")  # [Hello]\nregex_set += \" world\"\nprint(regex_set)  # \"[Hello world]\"\n\n\n\n\n__add__\n\n\nExpects variables of type \nstr\n and \nRegex\n. Unlike the overload of \n__iadd__\n, this overload returns a new \nRegex\n object.\n\n\n\n\n+ str\n: concatenates \nself.rgx\n (accessed via method \nget\n) with the value of the passed variable;\n\n\n+ Regex\n: concatenates \nself.rgx\n (accessed via method \nget\n) with the value of \nself.rgx\n of the passed object (also accessed via method \nget\n).\n\n\n\n\nfrom mre import Regex\n\nregex_one = Regex(\"Hello\") + \" \" + Regex(\"world\")\nregex_two = Regex(\"Hello\") + Regex(\" world\")\n\nprint(regex_one)  # \"Hello world\"\nprint(regex_two)  # \"Hello world\"\n\n\n\n\nget\n\n\nReturns the value stored in \nself.rgx\n.\n\n\nfrom mre import Regex\n\nregex = Regex(\"stored value\")\nprint(regex.get())  # \"stored value\"\n\n\n\n\nquantifier\n\n\nHas the following parameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\nDefault value\n\n\n\n\n\n\n\n\n\n\nn\n\n\nint\n\n\n0\n\n\n\n\n\n\nm\n\n\nint\n\n\n0\n\n\n\n\n\n\nwithout_maximum\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nUsed to quantify how often a Regex may/should appear (from \nn\n to \nm\n). Returns a new \nRegex\n.\n\n\nIn specific cases, a symbol is added. These cases are:\n\n\n\n\n\n\n\n\nn\n\n\nm\n\n\nwithout_maximum\n\n\nSymbol\n\n\nAccess\n\n\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n-\n\n\n?\n\n\nRegex.ZERO_OR_ONE\n\n\n\n\n\n\n0\n\n\n-\n\n\nTrue\n\n\n*\n\n\nRegex.ZERO_OR_MULTIPLE\n\n\n\n\n\n\n1\n\n\n-\n\n\nTrue\n\n\n+\n\n\nRegex.ONE_OR_MULTIPLE\n\n\n\n\n\n\n\n\nIn addition to these specific cases, quantification may occur as follows:\n- \n{n}\n: should occur \nn\n times;\n- \n{n, m}\n: may occur from \nn\n up to \nm\n times.\n\n\nfrom mre import Regex\n\ndigits = Regex(\"[0-9]\")\n\nprint(digits.quantifier(3))  # \"[0-9]{3}\"\nprint(digits.quantifier(3, 5))  # \"[0-9]{3,5}\"\nprint(digits.quantifier(0, 1))  # \"[0-9]?\"\nprint(digits.quantifier(0, without_maximum=True))  # \"[0-9]*\"\nprint(digits.quantifier(1, without_maximum=True))  # \"[0-9]+\"\n\n\n\n\nbackreferences\n\n\nHas a parameter of type \nint\n (\ngroup_n\n) which is used to indicate which group you want to perform a \nbackreference\n. Returns a \nRegex\n which performs \nbackreferences\n of the indicated group.\n\n\nAn alternative way of calling this method, is providing an \nint\n to the constructor.\n\n\nfrom mre import Regex\n\nregex_one = Regex().backreferences(1)\nregex_two = Regex(2)\n\nprint(regex_one)  # \"\\1\"\nprint(regex_two)  # \"\\2\"\n\n\n\n\nQuantifier\n\n\nThis class serves as an alternative to calling \nRegex.quantifier\n. The constructor has 4 parameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\ndefault value\n\n\n\n\n\n\n\n\n\n\nregex\n\n\nstr\n, \nint\n, \nRegex\n\n\n\"\"\n\n\n\n\n\n\nn\n\n\nint\n\n\n0\n\n\n\n\n\n\nm\n\n\nint\n\n\n0\n\n\n\n\n\n\nwithout_maximum\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nThe first parameter refers to the RegEx you want to create, the other three are used to call method \nRegex.quantifier\n.\n\n\nfrom mre import Regex, Quantifier\n\ndigits_one = Regex(\"[0-9]\").quantifier(3, 5)\ndigits_two = Quantifier(\"[0-9]\", 3, 5)\n\nprint(digits_one)  # \"[0-9]{3,5}\"\nprint(digits_two)  # \"[0-9]{3,5}\"\n\n\n\n\nSet\n\n\nThis class represents a set in RegEx. The constructor is identical to \nRegex\n.\n\n\nfrom mre import Set\n\nregex_set = Set(\"0-9\")\n\nprint(regex_set)  # \"[0-9]\"\nprint(regex_set.quantifier(3))  # \"[0-9]{3}\"\n\n\n\n\nMethods\n\n\nThis class inherits the methods of class \nRegex\n, overriding the following.\n\n\nget\n\n\nReturns the value stored in \nself.rgx\n, but within brackets.\n\n\nfrom mre import Set\n\nregex_set = Set(\"0-9\")\nprint(regex_set.get())  # \"[0-9]\"\n\n\n\n\nquantifier\n\n\nReturns a new \nRegex\n objects with a quantifier for the set.\n\n\nfrom mre import Set\n\nregex_set = Set(\"0-9\")\n\nprint(regex_set)  # \"[0-9]\"\nprint(regex_set.quantifier(3))  # \"[0-9]{3}\"\n\nprint(type(regex_set))  # <class 'mre.Set.Set'>\nprint(type(regex_set.quantifier(3)))  # <class 'mre.Regex.Regex'>\n\n\n\n\nGroup\n\n\nThis class represents a group in RegEx. The constructor has two parameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\ndefault value\n\n\n\n\n\n\n\n\n\n\nregex\n\n\nstr\n, \nint\n, \nRegex\n\n\n\"\"\n\n\n\n\n\n\nnon_capturing\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nIf the argument for \nnon_capturing\n is \nTrue\n, the symbol indicating \nRegEx Engine\n to return a non capturing group is added(\n?:\n).\n\n\nfrom mre import Group\n\nregex_group_one = Group('<h1>') + Group('[\\w\\s]+') + Group('</h1>')\nregex_group_two = Group('<h1>', True) + Group('[\\w\\s]+') + Group('</h1>', True)\n\nprint(regex_group_one)  # (<h1>)([\\w\\s]+)(</h1>)\nprint(regex_group_two)  # (?:<h1>)([\\w\\s]+)(?:</h1>)\n\n\n\n\nMethods\n\n\nThis class inherits the methods of class \nRegex\n, overriding the following.\n\n\nget\n\n\nReturns the value stored in \nself.rgx\n, but within parentheses.\n\n\nfrom mre import Group\n\nregex_group_one = Group(\"<h1>\")\nregex_group_two = Group(\"</h1>\", True)\n\nprint(regex_group_one.get())  # \"(<h1>)\"\nprint(regex_group_two.get())  # \"(?:</h1>)\"\n\n\n\n\nquantifier\n\n\nReturns a new \nRegex\n objects with a quantifier for the group.\n\n\nfrom mre import Group\n\nregex_group = Group(\"<h1>\")\n\nprint(regex_group)  # \"(<h1>)\"\nprint(regex_group.quantifier(3))  # \"(<h1>){3}\"\n\nprint(type(regex_group))  # <class 'mre.Group.Group'>\nprint(type(regex_group.quantifier(3)))  # <class 'mre.Regex.Regex'>\n\n\n\n\nAnchor\n\n\nThis class respresents an anchored RegEx (the RegEx must start and end as defined). The constructor has two parameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\ndefault value\n\n\n\n\n\n\n\n\n\n\nregex\n\n\nstr\n, \nint\n, \nRegex\n\n\n\"\"\n\n\n\n\n\n\nnegate\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nIf the argument for \nnegate\n is \nTrue\n, the inverse pattern symbol is added, i.e. the RegEx must not start and end as defined.\n\n\nfrom mre import Anchor\n\nregex_anchor_one = Anchor(\"\\\\d{4}-\\\\w+.txt\")\nregex_anchor_two = Anchor(\"\\\\d{4}-\\\\w+.txt\", True)\n\nprint(regex_anchor_one)  # \"^\\d{4}-\\w+.txt$\"\nprint(regex_anchor_two)  # \"\\b\\d{4}-\\w+.txt\\B\"\n\n\n\n\nMethods\n\n\nThis class inherits the methods of class \nRegex\n, overriding the following.\n\n\nget\n\n\nReturns the value stored in \nself.rgx\n, but anchored.\n\n\nfrom mre import Anchor\n\nregex_anchor_one = Anchor(\"<h1>Hello world<\\/h1>\")\nregex_anchor_two = Anchor(\"<h1>Hello world<\\/h1>\", True)\n\nprint(regex_anchor_one.get())  # \"^<h1>Hello world</h1>$\"\nprint(regex_anchor_two.get())  # \"\\b<h1>Hello world</h1>\\B\"\n\n\n\n\nhelper.Range\n\n\nThis class is intended to assist in creating a RegEx that indicates a character class in form of a \nrange\n. The constructor has two parameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\ndefault value\n\n\n\n\n\n\n\n\n\n\nminimum\n\n\nstr\n, \nint\n\n\n0\n\n\n\n\n\n\nmaximum\n\n\nstr\n, \nint\n\n\n\"z\"\n\n\n\n\n\n\n\n\nIdeally you should use this class together with a \nSet\n. Within a \nSet\n the hyphen has a \"magic\" value, that allows it to assign a range. Outside of a set a hyphen has only the hyphen value. So if you want lowercase letters, you should use \n[a-z]\n instead of \na-z\n. \na-z\n indicates you only want the values \na\n, \n-\n and \nz\n.\n\n\nfrom mre.helper import Range\n\n# all digits\ndigits = Range(0, 9)\n# all letters\nletters = Range('A', 'z')\n\nprint(digits)  # \"0-9\"\nprint(letters)  # \"A-z\"\n\n\n\n\nMethods\n\n\nThis class inherits the methods of the \nRegex\n class and has its own methods.\n\n\ndigits\n\n\nHas two parameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\ndefault value\n\n\n\n\n\n\n\n\n\n\nminimum\n\n\nint\n\n\n0\n\n\n\n\n\n\nmaximum\n\n\nint\n\n\n9\n\n\n\n\n\n\n\n\nReturns a \nrange\n that is defined as the digits between \nminimum\n and \nmaximum\n.\n\n\nfrom mre.helper import Range\n\nregex_range_one = Range(0, 9)\nregex_range_two = Range().digits()\nregex_range_three = Range(0, 6)\nregex_range_four = Range().digits(0, 6)\n\nprint(regex_range_one)  # \"0-9\"\nprint(regex_range_two)  # \"0-9\"\nprint(regex_range_three)  # \"0-6\"\nprint(regex_range_four)  # \"0-6\"\n\n\n\n\nletters\n\n\nHas four parameters:\n\n\n\n\n\n\n\n\nParameter\n\n\nType\n\n\ndefault value\n\n\n\n\n\n\n\n\n\n\nminimum\n\n\nchr\n\n\nA\n\n\n\n\n\n\nmaximum\n\n\nchr\n\n\nz\n\n\n\n\n\n\nuppercase\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\nlowercase\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nReturns a \nrange\n that is defined as the letters between \nminimum\n and \nmaximum\n.\n\n\nfrom mre.helper import Range\n\n# all letters\nregex_range_one = Range('A', 'z')\nregex_range_two = Range().letters()\nregex_range_three = Range().letters('A', 'z')\nregex_range_four = Range().letters(uppercase=True, lowercase=True)\n# all capital letters\nregex_range_five = Range().letters(uppercase=True)\n# all lowercase letters\nregex_range_six = Range().letters(lowercase=True)\n\nprint(regex_range_one)  # \"A-z\"\nprint(regex_range_two)  # \"A-z\"\nprint(regex_range_three)  # \"A-z\"\nprint(regex_range_four)  # \"A-z\"\nprint(regex_range_five)  # \"A-Z\"\nprint(regex_range_six)  # \"a-z\"\n\n\n\n\nExamples\n\n\n2 ways to create a RegEx for a \nCEP\n (brazilian postal code) (\n[0-9]{5}-?[0-9]{3}\n):\n\n\nfrom mre import Regex, Set\n\n# all digits\ndigits = Set(Regex(\"0-9\"))\n\nrgx_cep = Regex(\n    digits.quantifier(5),\n    Regex(\"-\").quantifier(0, 1),\n    digits.quantifier(3),\n)\n\n\n\n\nfrom mre import Regex, Quantifier, Set\nfrom mre.helper import Range\n\n# all digits [0-9]\ndigits = Set(Range().digits())\n# the hyphen may appear zero or one times\nhyphen = Quantifier(\"-\", 0, 1)\n\nrgx_cep = Regex(\n    digits.quantifier(5), hyphen,\n    digits.quantifier(3),\n)\n\n\n\n\nRegEx for a \nCPF\n (brazilian tax payer registry number) (\n[0-9]{3}.?[0-9]{3}.?[0-9]{3}-?[0-9]{2}\n):\n\n\nfrom mre import Regex, Set\nfrom mre.helper import Range\n\n# all digits\nall_digits = Set(Range(0, 9))\n# the dot may appear zero or one times\ndot = Regex(Regex.DOT).quantifier(0, 1)\n# the hyphen may appear zero or one times\nhyphen = Regex('-').quantifier(0, 1)\n\nrgx_cpf = Regex(\n    all_digits.quantifier(3), dot,\n    all_digits.quantifier(3), dot,\n    all_digits.quantifier(3), hyphen,\n    all_digits.quantifier(2),\n)\n\n\n\n\nRegEx for a \nCNPJ\n (ID in the brazilian National Registry of Legal Entities) (\n\\d{2}\\.?\\d{3}\\.?\\d{3}\\/?\\d{4}\\-?\\d{2}\n):\n\n\nfrom mre import Regex, Quantifier\n\n# all digits\ndigits = Regex(Regex.DIGIT)\n# the dot may appear zero or one times\ndot = Regex(Regex.DOT).quantifier(0, 1)\n# the slash may appear zero or one times\nslash = Regex(Regex.SLASH).quantifier(0, 1)\n# the hyphen may appear zero or one times\nhyphen = Quantifier(\"-\", 0, 1)\n\nrgx_cnpj = Regex(\n    digits.quantifier(2), dot,\n    digits.quantifier(3), dot,\n    digits.quantifier(3), slash,\n    digits.quantifier(4), hyphen,\n    digits.quantifier(2),\n)",
            "title": "How to use"
        },
        {
            "location": "/en/how-to-use/#classes",
            "text": "Regex  Quantifier  Set  Group  Anchor  Helper  Range",
            "title": "Classes"
        },
        {
            "location": "/en/how-to-use/#regex",
            "text": "This is the parent class of all other classes in this package, the RegEx is being handled in variable  self.rgx . Your constructor can receive any number of inputs, but they require the following types:  str ,  int  and the  Regex  class itself. For better understanding:   str : concatenates to variable  self.rgx ;  int : performs  backreferences ;  Regex : concatenates the value of  self.rgx  of the passed object to variable  self.rgx  of the receiving object.   Ways to declare a  Regex :  from mre import Regex, Group\n\nrgx_one = Regex(\"Hello world\")  # Hello world\nrgx_two = Regex(\"Hello\", \" world\")  # Hello world\nrgx_three = Regex(\"Hello\") + \" \" + Regex(\"world\")  # Hello world\nrgx_four = Regex('<', Group('h[1-6]'), '>')  # <(h[1-6])>\nrgx_five = Regex('<', Regex.SLASH, 1, '>')  # <\\/\\1>",
            "title": "Regex"
        },
        {
            "location": "/en/how-to-use/#constants",
            "text": "Constants available in class  Regex :     Constant  Value      ANY  .    DOT  \\\\.    DIGIT  \\\\d    WHITESPACE  \\\\s    WORD_CHARS  \\\\w    SLASH  \\\\/.    NOT_DIGIT  \\\\D    NOT_WHITESPACE  \\\\S    NOT_WORD_CHARS  \\\\W    ZERO_OR_ONE  ?    ZERO_OR_MULTIPLE  *    ONE_OR_MULTIPLE  +    HYPHEN  \\\\-",
            "title": "Constants"
        },
        {
            "location": "/en/how-to-use/#methods",
            "text": "Descriptions of methods and overloads.",
            "title": "Methods"
        },
        {
            "location": "/en/how-to-use/#9595str9595",
            "text": "Returns the value stored in  self.rgx .  from mre import Regex\n\nregex = Regex(\"Hello world\")\nprint(regex)  # \"Hello world\"",
            "title": "__str__"
        },
        {
            "location": "/en/how-to-use/#9595eq9595",
            "text": "Comparisons are possible with  str  and  Regex  type:\n-  == str : compares  self.rgx  to the value of the passed variable;\n-  == Regex : compares  self.rgx  (accessed via method  get ) to the value of  self.rgx  of the passed object (also accessed via method  get ).  from mre import Regex\n\nregex_one = Regex(\"Hello world\")\n\nprint(regex_one == \"Hello world\")  # True\nprint(regex_one == \"Hello world!\")  # False\n\nprint(regex_one == Regex(\"Hello world\"))  # True\nprint(regex_one == Regex(\"Hello world!\"))  # False",
            "title": "__eq__"
        },
        {
            "location": "/en/how-to-use/#9595iadd9595",
            "text": "Expects variables of type  str  and  Regex . For better understanding:   += str : concatenates  self.rgx  with the value of the passed variable;  += Regex : concatenates  self.rgx  with the value of variable  self.rgx  of the passed object (accessed via method  get ).   The overload directly changes the value of  self.rgx . In case of operations like  Set  of an object, it will change to the value between to brackets.  from mre import Regex, Set\n\nregex = Regex(\"Hello\")\nregex += \" world\"\nprint(regex)  # \"Hello world\"\n\nregex_set = Set(\"Hello\")  # [Hello]\nregex_set += \" world\"\nprint(regex_set)  # \"[Hello world]\"",
            "title": "__iadd__"
        },
        {
            "location": "/en/how-to-use/#9595add9595",
            "text": "Expects variables of type  str  and  Regex . Unlike the overload of  __iadd__ , this overload returns a new  Regex  object.   + str : concatenates  self.rgx  (accessed via method  get ) with the value of the passed variable;  + Regex : concatenates  self.rgx  (accessed via method  get ) with the value of  self.rgx  of the passed object (also accessed via method  get ).   from mre import Regex\n\nregex_one = Regex(\"Hello\") + \" \" + Regex(\"world\")\nregex_two = Regex(\"Hello\") + Regex(\" world\")\n\nprint(regex_one)  # \"Hello world\"\nprint(regex_two)  # \"Hello world\"",
            "title": "__add__"
        },
        {
            "location": "/en/how-to-use/#get",
            "text": "Returns the value stored in  self.rgx .  from mre import Regex\n\nregex = Regex(\"stored value\")\nprint(regex.get())  # \"stored value\"",
            "title": "get"
        },
        {
            "location": "/en/how-to-use/#quantifier",
            "text": "Has the following parameters:     Parameter  Type  Default value      n  int  0    m  int  0    without_maximum  bool  False     Used to quantify how often a Regex may/should appear (from  n  to  m ). Returns a new  Regex .  In specific cases, a symbol is added. These cases are:     n  m  without_maximum  Symbol  Access      0  1  -  ?  Regex.ZERO_OR_ONE    0  -  True  *  Regex.ZERO_OR_MULTIPLE    1  -  True  +  Regex.ONE_OR_MULTIPLE     In addition to these specific cases, quantification may occur as follows:\n-  {n} : should occur  n  times;\n-  {n, m} : may occur from  n  up to  m  times.  from mre import Regex\n\ndigits = Regex(\"[0-9]\")\n\nprint(digits.quantifier(3))  # \"[0-9]{3}\"\nprint(digits.quantifier(3, 5))  # \"[0-9]{3,5}\"\nprint(digits.quantifier(0, 1))  # \"[0-9]?\"\nprint(digits.quantifier(0, without_maximum=True))  # \"[0-9]*\"\nprint(digits.quantifier(1, without_maximum=True))  # \"[0-9]+\"",
            "title": "quantifier"
        },
        {
            "location": "/en/how-to-use/#backreferences",
            "text": "Has a parameter of type  int  ( group_n ) which is used to indicate which group you want to perform a  backreference . Returns a  Regex  which performs  backreferences  of the indicated group.  An alternative way of calling this method, is providing an  int  to the constructor.  from mre import Regex\n\nregex_one = Regex().backreferences(1)\nregex_two = Regex(2)\n\nprint(regex_one)  # \"\\1\"\nprint(regex_two)  # \"\\2\"",
            "title": "backreferences"
        },
        {
            "location": "/en/how-to-use/#quantifier_1",
            "text": "This class serves as an alternative to calling  Regex.quantifier . The constructor has 4 parameters:     Parameter  Type  default value      regex  str ,  int ,  Regex  \"\"    n  int  0    m  int  0    without_maximum  bool  False     The first parameter refers to the RegEx you want to create, the other three are used to call method  Regex.quantifier .  from mre import Regex, Quantifier\n\ndigits_one = Regex(\"[0-9]\").quantifier(3, 5)\ndigits_two = Quantifier(\"[0-9]\", 3, 5)\n\nprint(digits_one)  # \"[0-9]{3,5}\"\nprint(digits_two)  # \"[0-9]{3,5}\"",
            "title": "Quantifier"
        },
        {
            "location": "/en/how-to-use/#set",
            "text": "This class represents a set in RegEx. The constructor is identical to  Regex .  from mre import Set\n\nregex_set = Set(\"0-9\")\n\nprint(regex_set)  # \"[0-9]\"\nprint(regex_set.quantifier(3))  # \"[0-9]{3}\"",
            "title": "Set"
        },
        {
            "location": "/en/how-to-use/#methods_1",
            "text": "This class inherits the methods of class  Regex , overriding the following.",
            "title": "Methods"
        },
        {
            "location": "/en/how-to-use/#get_1",
            "text": "Returns the value stored in  self.rgx , but within brackets.  from mre import Set\n\nregex_set = Set(\"0-9\")\nprint(regex_set.get())  # \"[0-9]\"",
            "title": "get"
        },
        {
            "location": "/en/how-to-use/#quantifier_2",
            "text": "Returns a new  Regex  objects with a quantifier for the set.  from mre import Set\n\nregex_set = Set(\"0-9\")\n\nprint(regex_set)  # \"[0-9]\"\nprint(regex_set.quantifier(3))  # \"[0-9]{3}\"\n\nprint(type(regex_set))  # <class 'mre.Set.Set'>\nprint(type(regex_set.quantifier(3)))  # <class 'mre.Regex.Regex'>",
            "title": "quantifier"
        },
        {
            "location": "/en/how-to-use/#group",
            "text": "This class represents a group in RegEx. The constructor has two parameters:     Parameter  Type  default value      regex  str ,  int ,  Regex  \"\"    non_capturing  bool  False     If the argument for  non_capturing  is  True , the symbol indicating  RegEx Engine  to return a non capturing group is added( ?: ).  from mre import Group\n\nregex_group_one = Group('<h1>') + Group('[\\w\\s]+') + Group('</h1>')\nregex_group_two = Group('<h1>', True) + Group('[\\w\\s]+') + Group('</h1>', True)\n\nprint(regex_group_one)  # (<h1>)([\\w\\s]+)(</h1>)\nprint(regex_group_two)  # (?:<h1>)([\\w\\s]+)(?:</h1>)",
            "title": "Group"
        },
        {
            "location": "/en/how-to-use/#methods_2",
            "text": "This class inherits the methods of class  Regex , overriding the following.",
            "title": "Methods"
        },
        {
            "location": "/en/how-to-use/#get_2",
            "text": "Returns the value stored in  self.rgx , but within parentheses.  from mre import Group\n\nregex_group_one = Group(\"<h1>\")\nregex_group_two = Group(\"</h1>\", True)\n\nprint(regex_group_one.get())  # \"(<h1>)\"\nprint(regex_group_two.get())  # \"(?:</h1>)\"",
            "title": "get"
        },
        {
            "location": "/en/how-to-use/#quantifier_3",
            "text": "Returns a new  Regex  objects with a quantifier for the group.  from mre import Group\n\nregex_group = Group(\"<h1>\")\n\nprint(regex_group)  # \"(<h1>)\"\nprint(regex_group.quantifier(3))  # \"(<h1>){3}\"\n\nprint(type(regex_group))  # <class 'mre.Group.Group'>\nprint(type(regex_group.quantifier(3)))  # <class 'mre.Regex.Regex'>",
            "title": "quantifier"
        },
        {
            "location": "/en/how-to-use/#anchor",
            "text": "This class respresents an anchored RegEx (the RegEx must start and end as defined). The constructor has two parameters:     Parameter  Type  default value      regex  str ,  int ,  Regex  \"\"    negate  bool  False     If the argument for  negate  is  True , the inverse pattern symbol is added, i.e. the RegEx must not start and end as defined.  from mre import Anchor\n\nregex_anchor_one = Anchor(\"\\\\d{4}-\\\\w+.txt\")\nregex_anchor_two = Anchor(\"\\\\d{4}-\\\\w+.txt\", True)\n\nprint(regex_anchor_one)  # \"^\\d{4}-\\w+.txt$\"\nprint(regex_anchor_two)  # \"\\b\\d{4}-\\w+.txt\\B\"",
            "title": "Anchor"
        },
        {
            "location": "/en/how-to-use/#methods_3",
            "text": "This class inherits the methods of class  Regex , overriding the following.",
            "title": "Methods"
        },
        {
            "location": "/en/how-to-use/#get_3",
            "text": "Returns the value stored in  self.rgx , but anchored.  from mre import Anchor\n\nregex_anchor_one = Anchor(\"<h1>Hello world<\\/h1>\")\nregex_anchor_two = Anchor(\"<h1>Hello world<\\/h1>\", True)\n\nprint(regex_anchor_one.get())  # \"^<h1>Hello world</h1>$\"\nprint(regex_anchor_two.get())  # \"\\b<h1>Hello world</h1>\\B\"",
            "title": "get"
        },
        {
            "location": "/en/how-to-use/#helperrange",
            "text": "This class is intended to assist in creating a RegEx that indicates a character class in form of a  range . The constructor has two parameters:     Parameter  Type  default value      minimum  str ,  int  0    maximum  str ,  int  \"z\"     Ideally you should use this class together with a  Set . Within a  Set  the hyphen has a \"magic\" value, that allows it to assign a range. Outside of a set a hyphen has only the hyphen value. So if you want lowercase letters, you should use  [a-z]  instead of  a-z .  a-z  indicates you only want the values  a ,  -  and  z .  from mre.helper import Range\n\n# all digits\ndigits = Range(0, 9)\n# all letters\nletters = Range('A', 'z')\n\nprint(digits)  # \"0-9\"\nprint(letters)  # \"A-z\"",
            "title": "helper.Range"
        },
        {
            "location": "/en/how-to-use/#methods_4",
            "text": "This class inherits the methods of the  Regex  class and has its own methods.",
            "title": "Methods"
        },
        {
            "location": "/en/how-to-use/#digits",
            "text": "Has two parameters:     Parameter  Type  default value      minimum  int  0    maximum  int  9     Returns a  range  that is defined as the digits between  minimum  and  maximum .  from mre.helper import Range\n\nregex_range_one = Range(0, 9)\nregex_range_two = Range().digits()\nregex_range_three = Range(0, 6)\nregex_range_four = Range().digits(0, 6)\n\nprint(regex_range_one)  # \"0-9\"\nprint(regex_range_two)  # \"0-9\"\nprint(regex_range_three)  # \"0-6\"\nprint(regex_range_four)  # \"0-6\"",
            "title": "digits"
        },
        {
            "location": "/en/how-to-use/#letters",
            "text": "Has four parameters:     Parameter  Type  default value      minimum  chr  A    maximum  chr  z    uppercase  bool  False    lowercase  bool  False     Returns a  range  that is defined as the letters between  minimum  and  maximum .  from mre.helper import Range\n\n# all letters\nregex_range_one = Range('A', 'z')\nregex_range_two = Range().letters()\nregex_range_three = Range().letters('A', 'z')\nregex_range_four = Range().letters(uppercase=True, lowercase=True)\n# all capital letters\nregex_range_five = Range().letters(uppercase=True)\n# all lowercase letters\nregex_range_six = Range().letters(lowercase=True)\n\nprint(regex_range_one)  # \"A-z\"\nprint(regex_range_two)  # \"A-z\"\nprint(regex_range_three)  # \"A-z\"\nprint(regex_range_four)  # \"A-z\"\nprint(regex_range_five)  # \"A-Z\"\nprint(regex_range_six)  # \"a-z\"",
            "title": "letters"
        },
        {
            "location": "/en/how-to-use/#examples",
            "text": "2 ways to create a RegEx for a  CEP  (brazilian postal code) ( [0-9]{5}-?[0-9]{3} ):  from mre import Regex, Set\n\n# all digits\ndigits = Set(Regex(\"0-9\"))\n\nrgx_cep = Regex(\n    digits.quantifier(5),\n    Regex(\"-\").quantifier(0, 1),\n    digits.quantifier(3),\n)  from mre import Regex, Quantifier, Set\nfrom mre.helper import Range\n\n# all digits [0-9]\ndigits = Set(Range().digits())\n# the hyphen may appear zero or one times\nhyphen = Quantifier(\"-\", 0, 1)\n\nrgx_cep = Regex(\n    digits.quantifier(5), hyphen,\n    digits.quantifier(3),\n)  RegEx for a  CPF  (brazilian tax payer registry number) ( [0-9]{3}.?[0-9]{3}.?[0-9]{3}-?[0-9]{2} ):  from mre import Regex, Set\nfrom mre.helper import Range\n\n# all digits\nall_digits = Set(Range(0, 9))\n# the dot may appear zero or one times\ndot = Regex(Regex.DOT).quantifier(0, 1)\n# the hyphen may appear zero or one times\nhyphen = Regex('-').quantifier(0, 1)\n\nrgx_cpf = Regex(\n    all_digits.quantifier(3), dot,\n    all_digits.quantifier(3), dot,\n    all_digits.quantifier(3), hyphen,\n    all_digits.quantifier(2),\n)  RegEx for a  CNPJ  (ID in the brazilian National Registry of Legal Entities) ( \\d{2}\\.?\\d{3}\\.?\\d{3}\\/?\\d{4}\\-?\\d{2} ):  from mre import Regex, Quantifier\n\n# all digits\ndigits = Regex(Regex.DIGIT)\n# the dot may appear zero or one times\ndot = Regex(Regex.DOT).quantifier(0, 1)\n# the slash may appear zero or one times\nslash = Regex(Regex.SLASH).quantifier(0, 1)\n# the hyphen may appear zero or one times\nhyphen = Quantifier(\"-\", 0, 1)\n\nrgx_cnpj = Regex(\n    digits.quantifier(2), dot,\n    digits.quantifier(3), dot,\n    digits.quantifier(3), slash,\n    digits.quantifier(4), hyphen,\n    digits.quantifier(2),\n)",
            "title": "Examples"
        },
        {
            "location": "/en/",
            "text": "MRE\n\n\nA Python package to make regular expression (RegEx). Its purpose is to make creating a RegEx something easier to read.\n\n\nInstala\u00e7\u00e3o do MRE\n\n\nInstall the MRE package using pip:\n\n\npip install mre",
            "title": "Home"
        },
        {
            "location": "/en/#mre",
            "text": "A Python package to make regular expression (RegEx). Its purpose is to make creating a RegEx something easier to read.",
            "title": "MRE"
        },
        {
            "location": "/en/#instalacao-do-mre",
            "text": "Install the MRE package using pip:  pip install mre",
            "title": "Instala\u00e7\u00e3o do MRE"
        },
        {
            "location": "/es_ES/guia_de_uso/",
            "text": "Clases\n\n\n\n\nRegex\n\n\nQuantifier\n\n\nSet\n\n\nGroup\n\n\nAnchor\n\n\nHelper\n\n\nRange\n\n\n\n\n\n\n\n\nRegex\n\n\nEsta es la clase base de todas las demas clases en este paquete, el RegEx es manejado en la variable \nself.rgx\n. Tu constructor puede recibir cualquier n\u00famero de entradas, pero requiere los siguientes tipos: \nstr\n, \nint\n y la clasa \nRegEx\n misma. Para mejor entendimiento:\n\n\n\n\nstr\n: concatena a la variable \nself.rgx\n;\n\n\nint\n: realiza \nbackreferences\n;\n\n\nRegex\n: concatena el valor de \nself.rgx\n del objecto ingresado a la variable \nself.rgx\n del objeto receptor.\n\n\n\n\nManeras de declarar un \nRegex\n:\n\n\nfrom mre import Regex, Group\n\nrgx_one = Regex(\"Hello world\")  # Hello world\nrgx_two = Regex(\"Hello\", \" world\")  # Hello world\nrgx_three = Regex(\"Hello\") + \" \" + Regex(\"world\")  # Hello world\nrgx_four = Regex('<', Group('h[1-6]'), '>')  # <(h[1-6])>\nrgx_five = Regex('<', Regex.SLASH, 1, '>')  # <\\/\\1>\n\n\n\n\nConstantes\n\n\nConstantes disponibles en la clase \nRegex\n:\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nANY\n\n\n.\n\n\n\n\n\n\nDOT\n\n\n\\\\.\n\n\n\n\n\n\nDIGIT\n\n\n\\\\d\n\n\n\n\n\n\nWHITESPACE\n\n\n\\\\s\n\n\n\n\n\n\nWORD_CHARS\n\n\n\\\\w\n\n\n\n\n\n\nSLASH\n\n\n\\\\/.\n\n\n\n\n\n\nNOT_DIGIT\n\n\n\\\\D\n\n\n\n\n\n\nNOT_WHITESPACE\n\n\n\\\\S\n\n\n\n\n\n\nNOT_WORD_CHARS\n\n\n\\\\W\n\n\n\n\n\n\nZERO_OR_ONE\n\n\n?\n\n\n\n\n\n\nZERO_OR_MULTIPLE\n\n\n*\n\n\n\n\n\n\nONE_OR_MULTIPLE\n\n\n+\n\n\n\n\n\n\nHYPHEN\n\n\n\\\\-\n\n\n\n\n\n\n\n\nM\u00e9todos\n\n\nDescripciones de los m\u00e9todos y sobrecargas.\n\n\n__str__\n\n\nRetorna el valor almacenado en \nself.rgx\n.\n\n\nfrom mre import Regex\n\nregex = Regex(\"Hello world\")\nprint(regex)  # \"Hello world\"\n\n\n\n\n__eq__\n\n\nLas comparaciones son posibles con los tipos \nstr\n y \nRegex\n:\n- \n== str\n: compara \nself.rgx\n al valor de la variable ingresada;\n- \n== Regex\n: compara \nself.rgx\n (accedido mediante el m\u00e9todo \nget\n) al valor de \nself.rgx\n del objecto receptor (tambien accedido mediante el m\u00e9todo \nget\n).\n\n\nfrom mre import Regex\n\nregex_one = Regex(\"Hello world\")\n\nprint(regex_one == \"Hello world\")  # True\nprint(regex_one == \"Hello world!\")  # False\n\nprint(regex_one == Regex(\"Hello world\"))  # True\nprint(regex_one == Regex(\"Hello world!\"))  # False\n\n\n\n\n__iadd__\n\n\nEspera que la variable de tipo \nstr\n y \nRegex\n. Para mayor entendimiento:\n\n\n\n\n+= str\n: concatena \nself.rgx\n con el valor de la variable ingresada;\n\n\n+= Regex\n: concatena \nself.rgx\n con el valor de la variable \nself.rgx\n del object ingresado (accedido mediante el m\u00e9todo \nget\n).\n\n\n\n\nLa sobrecarga cambia directamente el valor de \nself.rgx\n. En caso de operacions como \nSet\n de un objecto, cambiar el valor entre par\u00e9ntesis.\n\n\nfrom mre import Regex, Set\n\nregex = Regex(\"Hello\")\nregex += \" world\"\nprint(regex)  # \"Hello world\"\n\nregex_set = Set(\"Hello\")  # [Hello]\nregex_set += \" world\"\nprint(regex_set)  # \"[Hello world]\"\n\n\n\n\n__add__\n\n\nEspera variables de tipo \nstr\n y \nRegex\n. A diference de la sobrecarga de \n__iadd__\n, esta sobrecarga retorna un nuevo objecto \nRegex\n.\n\n\n\n\n+ str\n: concatena \nself.rgx\n (accedido mediante el m\u00e9todo \nget\n) con el valor de la variable ingresada;\n\n\n+ Regex\n: concatenates \nself.rgx\n (accedido mediante el m\u00e9todo \nget\n) con el valor de \nself.rgx\n del objecto ingresado (tambien accedido mediante el m\u00e9todo \nget\n).\n\n\n\n\nfrom mre import Regex\n\nregex_one = Regex(\"Hello\") + \" \" + Regex(\"world\")\nregex_two = Regex(\"Hello\") + Regex(\" world\")\n\nprint(regex_one)  # \"Hello world\"\nprint(regex_two)  # \"Hello world\"\n\n\n\n\nget\n\n\nRetorna el valor almacenado en \nself.rgx\n.\n\n\nfrom mre import Regex\n\nregex = Regex(\"stored value\")\nprint(regex.get())  # \"stored value\"\n\n\n\n\nquantifier\n\n\nTiene los siguientes par\u00e1metros:\n\n\n\n\n\n\n\n\nPar\u00e1metro\n\n\nTipo\n\n\nValor por Defecto\n\n\n\n\n\n\n\n\n\n\nn\n\n\nint\n\n\n0\n\n\n\n\n\n\nm\n\n\nint\n\n\n0\n\n\n\n\n\n\nwithout_maximum\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nUsado para cuantificar que tan frecuente un Regex podria/deberia aparecer (de \nn\n a \nm\n). Retorna un nuevo \nRegex\n.\n\n\nEn casos especif\u00edcos, un simbolo es a\u00f1adido. Estos son los casos:\n\n\n\n\n\n\n\n\nn\n\n\nm\n\n\nwithout_maximum\n\n\nSimbolo\n\n\nAcceso\n\n\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n-\n\n\n?\n\n\nRegex.ZERO_OR_ONE\n\n\n\n\n\n\n0\n\n\n-\n\n\nTrue\n\n\n*\n\n\nRegex.ZERO_OR_MULTIPLE\n\n\n\n\n\n\n1\n\n\n-\n\n\nTrue\n\n\n+\n\n\nRegex.ONE_OR_MULTIPLE\n\n\n\n\n\n\n\n\nAdicionalmente a estos casos especif\u00edcos, la cuantificaci\u00f3n puede ocurrir de la siguiente forma:\n- \n{n}\n: deberia ocurrir \nn\n veces;\n- \n{n, m}\n: puede ocurrir desde \nn\n hasta \nm\n veces.\n\n\nfrom mre import Regex\n\ndigits = Regex(\"[0-9]\")\n\nprint(digits.quantifier(3))  # \"[0-9]{3}\"\nprint(digits.quantifier(3, 5))  # \"[0-9]{3,5}\"\nprint(digits.quantifier(0, 1))  # \"[0-9]?\"\nprint(digits.quantifier(0, without_maximum=True))  # \"[0-9]*\"\nprint(digits.quantifier(1, without_maximum=True))  # \"[0-9]+\"\n\n\n\n\nbackreferences\n\n\nTiene un par\u00e1metro de tipo \nint\n (\ngroup_n\n) el cu\u00e1l es usado par indicar cual grupo quieres que realize un \nbackreference\n. Retorna un \nRegex\n el cual realiza \nbackreferences\n del grupo indicado.\n\n\nUna forma alternativa de llamar este metodo, es proporcionando un \nint\n al constructor.\n\n\nfrom mre import Regex\n\nregex_one = Regex().backreferences(1)\nregex_two = Regex(2)\n\nprint(regex_one)  # \"\\1\"\nprint(regex_two)  # \"\\2\"\n\n\n\n\nQuantifier\n\n\nEsta clase funciona como una alternativa al llamado de \nRegex.quantifier\n. El constructor tiene 4 par\u00e1metros:\n\n\n\n\n\n\n\n\nPar\u00e1metro\n\n\nTipo\n\n\nValor por defecto\n\n\n\n\n\n\n\n\n\n\nregex\n\n\nstr\n, \nint\n, \nRegex\n\n\n\"\"\n\n\n\n\n\n\nn\n\n\nint\n\n\n0\n\n\n\n\n\n\nm\n\n\nint\n\n\n0\n\n\n\n\n\n\nwithout_maximum\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nEl primer par\u00e1metro refiere al RegEx que quieres crear, los otros tres son usados para llamar al m\u00e9todo \nRegex.quantifier\n.\n\n\nfrom mre import Regex, Quantifier\n\ndigits_one = Regex(\"[0-9]\").quantifier(3, 5)\ndigits_two = Quantifier(\"[0-9]\", 3, 5)\n\nprint(digits_one)  # \"[0-9]{3,5}\"\nprint(digits_two)  # \"[0-9]{3,5}\"\n\n\n\n\nSet\n\n\nEsta clase representa un set en RegEx. El constructor es identico a \nRegex\n.\n\n\nfrom mre import Set\n\nregex_set = Set(\"0-9\")\n\nprint(regex_set)  # \"[0-9]\"\nprint(regex_set.quantifier(3))  # \"[0-9]{3}\"\n\n\n\n\nM\u00e9todos\n\n\nEsta clase hereda los m\u00e9todos de la clase \nRegex\n, anulando lo siguiente.\n\n\nget\n\n\nRetorna el valor almacenado en \nself.rgx\n, pero dentro de par\u00e9ntesis.\n\n\nfrom mre import Set\n\nregex_set = Set(\"0-9\")\nprint(regex_set.get())  # \"[0-9]\"\n\n\n\n\nquantifier\n\n\nRetorna un nuevo object \nRegex\n con un cuantificador para el set.\n\n\nfrom mre import Set\n\nregex_set = Set(\"0-9\")\n\nprint(regex_set)  # \"[0-9]\"\nprint(regex_set.quantifier(3))  # \"[0-9]{3}\"\n\nprint(type(regex_set))  # <class 'mre.Set.Set'>\nprint(type(regex_set.quantifier(3)))  # <class 'mre.Regex.Regex'>\n\n\n\n\nGroup\n\n\nEsta clase representa a un grupo en RegEx. El constructor tiene dos par\u00e1metros:\n\n\n\n\n\n\n\n\nP\u00e1rametro\n\n\nTipo\n\n\nValor por defecto\n\n\n\n\n\n\n\n\n\n\nregex\n\n\nstr\n, \nint\n, \nRegex\n\n\n\"\"\n\n\n\n\n\n\nnon_capturing\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nSi el argumento para \nnon_capturing\n es \nTrue\n, el simbolo indicando \nRegEx Engine\n a retornar un grupo de no captura le es agregado(\n?:\n).\n\n\nfrom mre import Group\n\nregex_group_one = Group('<h1>') + Group('[\\w\\s]+') + Group('</h1>')\nregex_group_two = Group('<h1>', True) + Group('[\\w\\s]+') + Group('</h1>', True)\n\nprint(regex_group_one)  # (<h1>)([\\w\\s]+)(</h1>)\nprint(regex_group_two)  # (?:<h1>)([\\w\\s]+)(?:</h1>)\n\n\n\n\nM\u00e9todos\n\n\nEsta clase hereda los m\u00e9todos de la clase \nRegex\n, anulando lo siguiente.\n\n\nget\n\n\nRetorna el valor almacenado en \nself.rgx\n, pero dentro de par\u00e9ntesis.\n\n\nfrom mre import Group\n\nregex_group_one = Group(\"<h1>\")\nregex_group_two = Group(\"</h1>\", True)\n\nprint(regex_group_one.get())  # \"(<h1>)\"\nprint(regex_group_two.get())  # \"(?:</h1>)\"\n\n\n\n\nquantifier\n\n\nRetorna un nuevo object \nRegex\n con un cuantificador para el grupo.\n\n\nfrom mre import Group\n\nregex_group = Group(\"<h1>\")\n\nprint(regex_group)  # \"(<h1>)\"\nprint(regex_group.quantifier(3))  # \"(<h1>){3}\"\n\nprint(type(regex_group))  # <class 'mre.Group.Group'>\nprint(type(regex_group.quantifier(3)))  # <class 'mre.Regex.Regex'>\n\n\n\n\nAnchor\n\n\nEsta clase representa un RegEx anclado (el RegEx debe comenzar y terminar tal y como es definido). El constructor tiene 2 par\u00e1metros:\n\n\n\n\n\n\n\n\nPar\u00e1metro\n\n\nTipo\n\n\nValor por defecto\n\n\n\n\n\n\n\n\n\n\nregex\n\n\nstr\n, \nint\n, \nRegex\n\n\n\"\"\n\n\n\n\n\n\nnegate\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nSi el argumento para \nnegate\n es \nTrue\n, el simbolo de patr\u00f3n inverso es a\u00f1adido, ie. el RegEx no debe comenzar y terminar tal y como esta definido.\n\n\nfrom mre import Anchor\n\nregex_anchor_one = Anchor(\"\\\\d{4}-\\\\w+.txt\")\nregex_anchor_two = Anchor(\"\\\\d{4}-\\\\w+.txt\", True)\n\nprint(regex_anchor_one)  # \"^\\d{4}-\\w+.txt$\"\nprint(regex_anchor_two)  # \"\\b\\d{4}-\\w+.txt\\B\"\n\n\n\n\nM\u00e9todos\n\n\nEsta clase hereda los m\u00e9todos de la clase \nRegex\n, anulando lo siguiente.\n\n\nget\n\n\nRetorna el valor almacenado en \nself.rgx\n, pero anclado.\n\n\nfrom mre import Anchor\n\nregex_anchor_one = Anchor(\"<h1>Hello world<\\/h1>\")\nregex_anchor_two = Anchor(\"<h1>Hello world<\\/h1>\", True)\n\nprint(regex_anchor_one.get())  # \"^<h1>Hello world</h1>$\"\nprint(regex_anchor_two.get())  # \"\\b<h1>Hello world</h1>\\B\"\n\n\n\n\nhelper.Range\n\n\nEsta clase tiene como prop\u00f3sito asistir en creando un RegEx que indica una clase car\u00e1cter en forma de un \nrange\n. El constructor tiene dos par\u00e1metros:\n\n\n\n\n\n\n\n\nPar\u00e1metro\n\n\nTipo\n\n\nValor por defecto\n\n\n\n\n\n\n\n\n\n\nminimum\n\n\nstr\n, \nint\n\n\n0\n\n\n\n\n\n\nmaximum\n\n\nstr\n, \nint\n\n\n\"z\"\n\n\n\n\n\n\n\n\nIdealmente dberias usar esta clase junto a \nSet\n. Dentro de un \nSet\n el gui\u00f3n tiene un valor \"magico\", que le permite asignar un rango. Afuera de un set un gui\u00f3n tiene solo el valor del gui\u00f3n. As\u00ed que si quiere letras min\u00fasculas, deberias usar \n[a-z]\n en vez de \na-z\n. \na-z\n solo indica que quieres los valores \na\n, \n-\n y \nz\n.\n\n\nfrom mre.helper import Range\n\n# all digits\ndigits = Range(0, 9)\n# all letters\nletters = Range('A', 'z')\n\nprint(digits)  # \"0-9\"\nprint(letters)  # \"A-z\"\n\n\n\n\nM\u00e9todos\n\n\nEsta clase hereda los m\u00e9todos de la clase \nRegex\n y tiene sus propios m\u00e9todos.\n\n\ndigits\n\n\nTiene dos par\u00e1metros:\n\n\n\n\n\n\n\n\nPar\u00e1metro\n\n\nTipo\n\n\nValor por defecto\n\n\n\n\n\n\n\n\n\n\nminimum\n\n\nint\n\n\n0\n\n\n\n\n\n\nmaximum\n\n\nint\n\n\n9\n\n\n\n\n\n\n\n\nRetorna un \nrange\n que es definido como los d\u00edgitos entre \nminimun\n y \nmaximum\n.\n\n\nfrom mre.helper import Range\n\nregex_range_one = Range(0, 9)\nregex_range_two = Range().digits()\nregex_range_three = Range(0, 6)\nregex_range_four = Range().digits(0, 6)\n\nprint(regex_range_one)  # \"0-9\"\nprint(regex_range_two)  # \"0-9\"\nprint(regex_range_three)  # \"0-6\"\nprint(regex_range_four)  # \"0-6\"\n\n\n\n\nletters\n\n\nTiene cuatro par\u00e1metros:\n\n\n\n\n\n\n\n\nPar\u00e1metro\n\n\nTipo\n\n\nValor por defecto\n\n\n\n\n\n\n\n\n\n\nminimum\n\n\nchr\n\n\nA\n\n\n\n\n\n\nmaximum\n\n\nchr\n\n\nz\n\n\n\n\n\n\nuppercase\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\nlowercase\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nRetorna un \nrange\n que es definido como las letras entre \nminimun\n y \nmaximum\n.\n\n\nfrom mre.helper import Range\n\n# all letters\nregex_range_one = Range('A', 'z')\nregex_range_two = Range().letters()\nregex_range_three = Range().letters('A', 'z')\nregex_range_four = Range().letters(uppercase=True, lowercase=True)\n# all capital letters\nregex_range_five = Range().letters(uppercase=True)\n# all lowercase letters\nregex_range_six = Range().letters(lowercase=True)\n\nprint(regex_range_one)  # \"A-z\"\nprint(regex_range_two)  # \"A-z\"\nprint(regex_range_three)  # \"A-z\"\nprint(regex_range_four)  # \"A-z\"\nprint(regex_range_five)  # \"A-Z\"\nprint(regex_range_six)  # \"a-z\"\n\n\n\n\nEjemplos\n\n\n2 formas de crear un RegEx para un \nCEP\n (c\u00f3digo postal brasile\u00f1o) (\n[0-9]{5}-?[0-9]{3}\n):\n\n\nfrom mre import Regex, Set\n\n# all digits\ndigits = Set(Regex(\"0-9\"))\n\nrgx_cep = Regex(\n    digits.quantifier(5),\n    Regex(\"-\").quantifier(0, 1),\n    digits.quantifier(3),\n)\n\n\n\n\nfrom mre import Regex, Quantifier, Set\nfrom mre.helper import Range\n\n# all digits [0-9]\ndigits = Set(Range().digits())\n# the hyphen may appear zero or one times\nhyphen = Quantifier(\"-\", 0, 1)\n\nrgx_cep = Regex(\n    digits.quantifier(5), hyphen,\n    digits.quantifier(3),\n)\n\n\n\n\nRegEx para un \nCPF\n (n\u00famero de registro de contribuyente) (\n[0-9]{3}.?[0-9]{3}.?[0-9]{3}-?[0-9]{2}\n):\n\n\nfrom mre import Regex, Set\nfrom mre.helper import Range\n\n# all digits\nall_digits = Set(Range(0, 9))\n# the dot may appear zero or one times\ndot = Regex(Regex.DOT).quantifier(0, 1)\n# the hyphen may appear zero or one times\nhyphen = Regex('-').quantifier(0, 1)\n\nrgx_cpf = Regex(\n    all_digits.quantifier(3), dot,\n    all_digits.quantifier(3), dot,\n    all_digits.quantifier(3), hyphen,\n    all_digits.quantifier(2),\n)\n\n\n\n\nRegEx para un \nCNPJ\n (ID en el Registro Nacional de Entidades Legales brasile\u00f1o) (\n\\d{2}\\.?\\d{3}\\.?\\d{3}\\/?\\d{4}\\-?\\d{2}\n):\n\n\nfrom mre import Regex, Quantifier\n\n# all digits\ndigits = Regex(Regex.DIGIT)\n# the dot may appear zero or one times\ndot = Regex(Regex.DOT).quantifier(0, 1)\n# the slash may appear zero or one times\nslash = Regex(Regex.SLASH).quantifier(0, 1)\n# the hyphen may appear zero or one times\nhyphen = Quantifier(\"-\", 0, 1)\n\nrgx_cnpj = Regex(\n    digits.quantifier(2), dot,\n    digits.quantifier(3), dot,\n    digits.quantifier(3), slash,\n    digits.quantifier(4), hyphen,\n    digits.quantifier(2),\n)",
            "title": "Guia de uso"
        },
        {
            "location": "/es_ES/guia_de_uso/#clases",
            "text": "Regex  Quantifier  Set  Group  Anchor  Helper  Range",
            "title": "Clases"
        },
        {
            "location": "/es_ES/guia_de_uso/#regex",
            "text": "Esta es la clase base de todas las demas clases en este paquete, el RegEx es manejado en la variable  self.rgx . Tu constructor puede recibir cualquier n\u00famero de entradas, pero requiere los siguientes tipos:  str ,  int  y la clasa  RegEx  misma. Para mejor entendimiento:   str : concatena a la variable  self.rgx ;  int : realiza  backreferences ;  Regex : concatena el valor de  self.rgx  del objecto ingresado a la variable  self.rgx  del objeto receptor.   Maneras de declarar un  Regex :  from mre import Regex, Group\n\nrgx_one = Regex(\"Hello world\")  # Hello world\nrgx_two = Regex(\"Hello\", \" world\")  # Hello world\nrgx_three = Regex(\"Hello\") + \" \" + Regex(\"world\")  # Hello world\nrgx_four = Regex('<', Group('h[1-6]'), '>')  # <(h[1-6])>\nrgx_five = Regex('<', Regex.SLASH, 1, '>')  # <\\/\\1>",
            "title": "Regex"
        },
        {
            "location": "/es_ES/guia_de_uso/#constantes",
            "text": "Constantes disponibles en la clase  Regex :     Constant  Value      ANY  .    DOT  \\\\.    DIGIT  \\\\d    WHITESPACE  \\\\s    WORD_CHARS  \\\\w    SLASH  \\\\/.    NOT_DIGIT  \\\\D    NOT_WHITESPACE  \\\\S    NOT_WORD_CHARS  \\\\W    ZERO_OR_ONE  ?    ZERO_OR_MULTIPLE  *    ONE_OR_MULTIPLE  +    HYPHEN  \\\\-",
            "title": "Constantes"
        },
        {
            "location": "/es_ES/guia_de_uso/#metodos",
            "text": "Descripciones de los m\u00e9todos y sobrecargas.",
            "title": "M\u00e9todos"
        },
        {
            "location": "/es_ES/guia_de_uso/#9595str9595",
            "text": "Retorna el valor almacenado en  self.rgx .  from mre import Regex\n\nregex = Regex(\"Hello world\")\nprint(regex)  # \"Hello world\"",
            "title": "__str__"
        },
        {
            "location": "/es_ES/guia_de_uso/#9595eq9595",
            "text": "Las comparaciones son posibles con los tipos  str  y  Regex :\n-  == str : compara  self.rgx  al valor de la variable ingresada;\n-  == Regex : compara  self.rgx  (accedido mediante el m\u00e9todo  get ) al valor de  self.rgx  del objecto receptor (tambien accedido mediante el m\u00e9todo  get ).  from mre import Regex\n\nregex_one = Regex(\"Hello world\")\n\nprint(regex_one == \"Hello world\")  # True\nprint(regex_one == \"Hello world!\")  # False\n\nprint(regex_one == Regex(\"Hello world\"))  # True\nprint(regex_one == Regex(\"Hello world!\"))  # False",
            "title": "__eq__"
        },
        {
            "location": "/es_ES/guia_de_uso/#9595iadd9595",
            "text": "Espera que la variable de tipo  str  y  Regex . Para mayor entendimiento:   += str : concatena  self.rgx  con el valor de la variable ingresada;  += Regex : concatena  self.rgx  con el valor de la variable  self.rgx  del object ingresado (accedido mediante el m\u00e9todo  get ).   La sobrecarga cambia directamente el valor de  self.rgx . En caso de operacions como  Set  de un objecto, cambiar el valor entre par\u00e9ntesis.  from mre import Regex, Set\n\nregex = Regex(\"Hello\")\nregex += \" world\"\nprint(regex)  # \"Hello world\"\n\nregex_set = Set(\"Hello\")  # [Hello]\nregex_set += \" world\"\nprint(regex_set)  # \"[Hello world]\"",
            "title": "__iadd__"
        },
        {
            "location": "/es_ES/guia_de_uso/#9595add9595",
            "text": "Espera variables de tipo  str  y  Regex . A diference de la sobrecarga de  __iadd__ , esta sobrecarga retorna un nuevo objecto  Regex .   + str : concatena  self.rgx  (accedido mediante el m\u00e9todo  get ) con el valor de la variable ingresada;  + Regex : concatenates  self.rgx  (accedido mediante el m\u00e9todo  get ) con el valor de  self.rgx  del objecto ingresado (tambien accedido mediante el m\u00e9todo  get ).   from mre import Regex\n\nregex_one = Regex(\"Hello\") + \" \" + Regex(\"world\")\nregex_two = Regex(\"Hello\") + Regex(\" world\")\n\nprint(regex_one)  # \"Hello world\"\nprint(regex_two)  # \"Hello world\"",
            "title": "__add__"
        },
        {
            "location": "/es_ES/guia_de_uso/#get",
            "text": "Retorna el valor almacenado en  self.rgx .  from mre import Regex\n\nregex = Regex(\"stored value\")\nprint(regex.get())  # \"stored value\"",
            "title": "get"
        },
        {
            "location": "/es_ES/guia_de_uso/#quantifier",
            "text": "Tiene los siguientes par\u00e1metros:     Par\u00e1metro  Tipo  Valor por Defecto      n  int  0    m  int  0    without_maximum  bool  False     Usado para cuantificar que tan frecuente un Regex podria/deberia aparecer (de  n  a  m ). Retorna un nuevo  Regex .  En casos especif\u00edcos, un simbolo es a\u00f1adido. Estos son los casos:     n  m  without_maximum  Simbolo  Acceso      0  1  -  ?  Regex.ZERO_OR_ONE    0  -  True  *  Regex.ZERO_OR_MULTIPLE    1  -  True  +  Regex.ONE_OR_MULTIPLE     Adicionalmente a estos casos especif\u00edcos, la cuantificaci\u00f3n puede ocurrir de la siguiente forma:\n-  {n} : deberia ocurrir  n  veces;\n-  {n, m} : puede ocurrir desde  n  hasta  m  veces.  from mre import Regex\n\ndigits = Regex(\"[0-9]\")\n\nprint(digits.quantifier(3))  # \"[0-9]{3}\"\nprint(digits.quantifier(3, 5))  # \"[0-9]{3,5}\"\nprint(digits.quantifier(0, 1))  # \"[0-9]?\"\nprint(digits.quantifier(0, without_maximum=True))  # \"[0-9]*\"\nprint(digits.quantifier(1, without_maximum=True))  # \"[0-9]+\"",
            "title": "quantifier"
        },
        {
            "location": "/es_ES/guia_de_uso/#backreferences",
            "text": "Tiene un par\u00e1metro de tipo  int  ( group_n ) el cu\u00e1l es usado par indicar cual grupo quieres que realize un  backreference . Retorna un  Regex  el cual realiza  backreferences  del grupo indicado.  Una forma alternativa de llamar este metodo, es proporcionando un  int  al constructor.  from mre import Regex\n\nregex_one = Regex().backreferences(1)\nregex_two = Regex(2)\n\nprint(regex_one)  # \"\\1\"\nprint(regex_two)  # \"\\2\"",
            "title": "backreferences"
        },
        {
            "location": "/es_ES/guia_de_uso/#quantifier_1",
            "text": "Esta clase funciona como una alternativa al llamado de  Regex.quantifier . El constructor tiene 4 par\u00e1metros:     Par\u00e1metro  Tipo  Valor por defecto      regex  str ,  int ,  Regex  \"\"    n  int  0    m  int  0    without_maximum  bool  False     El primer par\u00e1metro refiere al RegEx que quieres crear, los otros tres son usados para llamar al m\u00e9todo  Regex.quantifier .  from mre import Regex, Quantifier\n\ndigits_one = Regex(\"[0-9]\").quantifier(3, 5)\ndigits_two = Quantifier(\"[0-9]\", 3, 5)\n\nprint(digits_one)  # \"[0-9]{3,5}\"\nprint(digits_two)  # \"[0-9]{3,5}\"",
            "title": "Quantifier"
        },
        {
            "location": "/es_ES/guia_de_uso/#set",
            "text": "Esta clase representa un set en RegEx. El constructor es identico a  Regex .  from mre import Set\n\nregex_set = Set(\"0-9\")\n\nprint(regex_set)  # \"[0-9]\"\nprint(regex_set.quantifier(3))  # \"[0-9]{3}\"",
            "title": "Set"
        },
        {
            "location": "/es_ES/guia_de_uso/#metodos_1",
            "text": "Esta clase hereda los m\u00e9todos de la clase  Regex , anulando lo siguiente.",
            "title": "M\u00e9todos"
        },
        {
            "location": "/es_ES/guia_de_uso/#get_1",
            "text": "Retorna el valor almacenado en  self.rgx , pero dentro de par\u00e9ntesis.  from mre import Set\n\nregex_set = Set(\"0-9\")\nprint(regex_set.get())  # \"[0-9]\"",
            "title": "get"
        },
        {
            "location": "/es_ES/guia_de_uso/#quantifier_2",
            "text": "Retorna un nuevo object  Regex  con un cuantificador para el set.  from mre import Set\n\nregex_set = Set(\"0-9\")\n\nprint(regex_set)  # \"[0-9]\"\nprint(regex_set.quantifier(3))  # \"[0-9]{3}\"\n\nprint(type(regex_set))  # <class 'mre.Set.Set'>\nprint(type(regex_set.quantifier(3)))  # <class 'mre.Regex.Regex'>",
            "title": "quantifier"
        },
        {
            "location": "/es_ES/guia_de_uso/#group",
            "text": "Esta clase representa a un grupo en RegEx. El constructor tiene dos par\u00e1metros:     P\u00e1rametro  Tipo  Valor por defecto      regex  str ,  int ,  Regex  \"\"    non_capturing  bool  False     Si el argumento para  non_capturing  es  True , el simbolo indicando  RegEx Engine  a retornar un grupo de no captura le es agregado( ?: ).  from mre import Group\n\nregex_group_one = Group('<h1>') + Group('[\\w\\s]+') + Group('</h1>')\nregex_group_two = Group('<h1>', True) + Group('[\\w\\s]+') + Group('</h1>', True)\n\nprint(regex_group_one)  # (<h1>)([\\w\\s]+)(</h1>)\nprint(regex_group_two)  # (?:<h1>)([\\w\\s]+)(?:</h1>)",
            "title": "Group"
        },
        {
            "location": "/es_ES/guia_de_uso/#metodos_2",
            "text": "Esta clase hereda los m\u00e9todos de la clase  Regex , anulando lo siguiente.",
            "title": "M\u00e9todos"
        },
        {
            "location": "/es_ES/guia_de_uso/#get_2",
            "text": "Retorna el valor almacenado en  self.rgx , pero dentro de par\u00e9ntesis.  from mre import Group\n\nregex_group_one = Group(\"<h1>\")\nregex_group_two = Group(\"</h1>\", True)\n\nprint(regex_group_one.get())  # \"(<h1>)\"\nprint(regex_group_two.get())  # \"(?:</h1>)\"",
            "title": "get"
        },
        {
            "location": "/es_ES/guia_de_uso/#quantifier_3",
            "text": "Retorna un nuevo object  Regex  con un cuantificador para el grupo.  from mre import Group\n\nregex_group = Group(\"<h1>\")\n\nprint(regex_group)  # \"(<h1>)\"\nprint(regex_group.quantifier(3))  # \"(<h1>){3}\"\n\nprint(type(regex_group))  # <class 'mre.Group.Group'>\nprint(type(regex_group.quantifier(3)))  # <class 'mre.Regex.Regex'>",
            "title": "quantifier"
        },
        {
            "location": "/es_ES/guia_de_uso/#anchor",
            "text": "Esta clase representa un RegEx anclado (el RegEx debe comenzar y terminar tal y como es definido). El constructor tiene 2 par\u00e1metros:     Par\u00e1metro  Tipo  Valor por defecto      regex  str ,  int ,  Regex  \"\"    negate  bool  False     Si el argumento para  negate  es  True , el simbolo de patr\u00f3n inverso es a\u00f1adido, ie. el RegEx no debe comenzar y terminar tal y como esta definido.  from mre import Anchor\n\nregex_anchor_one = Anchor(\"\\\\d{4}-\\\\w+.txt\")\nregex_anchor_two = Anchor(\"\\\\d{4}-\\\\w+.txt\", True)\n\nprint(regex_anchor_one)  # \"^\\d{4}-\\w+.txt$\"\nprint(regex_anchor_two)  # \"\\b\\d{4}-\\w+.txt\\B\"",
            "title": "Anchor"
        },
        {
            "location": "/es_ES/guia_de_uso/#metodos_3",
            "text": "Esta clase hereda los m\u00e9todos de la clase  Regex , anulando lo siguiente.",
            "title": "M\u00e9todos"
        },
        {
            "location": "/es_ES/guia_de_uso/#get_3",
            "text": "Retorna el valor almacenado en  self.rgx , pero anclado.  from mre import Anchor\n\nregex_anchor_one = Anchor(\"<h1>Hello world<\\/h1>\")\nregex_anchor_two = Anchor(\"<h1>Hello world<\\/h1>\", True)\n\nprint(regex_anchor_one.get())  # \"^<h1>Hello world</h1>$\"\nprint(regex_anchor_two.get())  # \"\\b<h1>Hello world</h1>\\B\"",
            "title": "get"
        },
        {
            "location": "/es_ES/guia_de_uso/#helperrange",
            "text": "Esta clase tiene como prop\u00f3sito asistir en creando un RegEx que indica una clase car\u00e1cter en forma de un  range . El constructor tiene dos par\u00e1metros:     Par\u00e1metro  Tipo  Valor por defecto      minimum  str ,  int  0    maximum  str ,  int  \"z\"     Idealmente dberias usar esta clase junto a  Set . Dentro de un  Set  el gui\u00f3n tiene un valor \"magico\", que le permite asignar un rango. Afuera de un set un gui\u00f3n tiene solo el valor del gui\u00f3n. As\u00ed que si quiere letras min\u00fasculas, deberias usar  [a-z]  en vez de  a-z .  a-z  solo indica que quieres los valores  a ,  -  y  z .  from mre.helper import Range\n\n# all digits\ndigits = Range(0, 9)\n# all letters\nletters = Range('A', 'z')\n\nprint(digits)  # \"0-9\"\nprint(letters)  # \"A-z\"",
            "title": "helper.Range"
        },
        {
            "location": "/es_ES/guia_de_uso/#metodos_4",
            "text": "Esta clase hereda los m\u00e9todos de la clase  Regex  y tiene sus propios m\u00e9todos.",
            "title": "M\u00e9todos"
        },
        {
            "location": "/es_ES/guia_de_uso/#digits",
            "text": "Tiene dos par\u00e1metros:     Par\u00e1metro  Tipo  Valor por defecto      minimum  int  0    maximum  int  9     Retorna un  range  que es definido como los d\u00edgitos entre  minimun  y  maximum .  from mre.helper import Range\n\nregex_range_one = Range(0, 9)\nregex_range_two = Range().digits()\nregex_range_three = Range(0, 6)\nregex_range_four = Range().digits(0, 6)\n\nprint(regex_range_one)  # \"0-9\"\nprint(regex_range_two)  # \"0-9\"\nprint(regex_range_three)  # \"0-6\"\nprint(regex_range_four)  # \"0-6\"",
            "title": "digits"
        },
        {
            "location": "/es_ES/guia_de_uso/#letters",
            "text": "Tiene cuatro par\u00e1metros:     Par\u00e1metro  Tipo  Valor por defecto      minimum  chr  A    maximum  chr  z    uppercase  bool  False    lowercase  bool  False     Retorna un  range  que es definido como las letras entre  minimun  y  maximum .  from mre.helper import Range\n\n# all letters\nregex_range_one = Range('A', 'z')\nregex_range_two = Range().letters()\nregex_range_three = Range().letters('A', 'z')\nregex_range_four = Range().letters(uppercase=True, lowercase=True)\n# all capital letters\nregex_range_five = Range().letters(uppercase=True)\n# all lowercase letters\nregex_range_six = Range().letters(lowercase=True)\n\nprint(regex_range_one)  # \"A-z\"\nprint(regex_range_two)  # \"A-z\"\nprint(regex_range_three)  # \"A-z\"\nprint(regex_range_four)  # \"A-z\"\nprint(regex_range_five)  # \"A-Z\"\nprint(regex_range_six)  # \"a-z\"",
            "title": "letters"
        },
        {
            "location": "/es_ES/guia_de_uso/#ejemplos",
            "text": "2 formas de crear un RegEx para un  CEP  (c\u00f3digo postal brasile\u00f1o) ( [0-9]{5}-?[0-9]{3} ):  from mre import Regex, Set\n\n# all digits\ndigits = Set(Regex(\"0-9\"))\n\nrgx_cep = Regex(\n    digits.quantifier(5),\n    Regex(\"-\").quantifier(0, 1),\n    digits.quantifier(3),\n)  from mre import Regex, Quantifier, Set\nfrom mre.helper import Range\n\n# all digits [0-9]\ndigits = Set(Range().digits())\n# the hyphen may appear zero or one times\nhyphen = Quantifier(\"-\", 0, 1)\n\nrgx_cep = Regex(\n    digits.quantifier(5), hyphen,\n    digits.quantifier(3),\n)  RegEx para un  CPF  (n\u00famero de registro de contribuyente) ( [0-9]{3}.?[0-9]{3}.?[0-9]{3}-?[0-9]{2} ):  from mre import Regex, Set\nfrom mre.helper import Range\n\n# all digits\nall_digits = Set(Range(0, 9))\n# the dot may appear zero or one times\ndot = Regex(Regex.DOT).quantifier(0, 1)\n# the hyphen may appear zero or one times\nhyphen = Regex('-').quantifier(0, 1)\n\nrgx_cpf = Regex(\n    all_digits.quantifier(3), dot,\n    all_digits.quantifier(3), dot,\n    all_digits.quantifier(3), hyphen,\n    all_digits.quantifier(2),\n)  RegEx para un  CNPJ  (ID en el Registro Nacional de Entidades Legales brasile\u00f1o) ( \\d{2}\\.?\\d{3}\\.?\\d{3}\\/?\\d{4}\\-?\\d{2} ):  from mre import Regex, Quantifier\n\n# all digits\ndigits = Regex(Regex.DIGIT)\n# the dot may appear zero or one times\ndot = Regex(Regex.DOT).quantifier(0, 1)\n# the slash may appear zero or one times\nslash = Regex(Regex.SLASH).quantifier(0, 1)\n# the hyphen may appear zero or one times\nhyphen = Quantifier(\"-\", 0, 1)\n\nrgx_cnpj = Regex(\n    digits.quantifier(2), dot,\n    digits.quantifier(3), dot,\n    digits.quantifier(3), slash,\n    digits.quantifier(4), hyphen,\n    digits.quantifier(2),\n)",
            "title": "Ejemplos"
        },
        {
            "location": "/es_ES/",
            "text": "MRE\n\n\nUn paquete de Python que permite create expresiones regulares (RegEx). Su proposito es hacer que la creacion de un RegEx se mas facil de leer.\n\n\nInstalaci\u00f3n de MRE\n\n\nInstala el paquete MRE usando pip:\n\n\npip install mre",
            "title": "Home"
        },
        {
            "location": "/es_ES/#mre",
            "text": "Un paquete de Python que permite create expresiones regulares (RegEx). Su proposito es hacer que la creacion de un RegEx se mas facil de leer.",
            "title": "MRE"
        },
        {
            "location": "/es_ES/#instalacion-de-mre",
            "text": "Instala el paquete MRE usando pip:  pip install mre",
            "title": "Instalaci\u00f3n de MRE"
        },
        {
            "location": "/pt_BR/guia-de-uso/",
            "text": "Classes\n\n\n\n\nRegex\n\n\nQuantifier\n\n\nSet\n\n\nGroup\n\n\nAnchor\n\n\nHelper\n\n\nRange\n\n\n\n\n\n\n\n\nRegex\n\n\nEssa \u00e9 a classe pai de todas as classes do pacote, o RegEx que se est\u00e1 manipulando fica na vari\u00e1vel \nself.rgx\n. Seu construtor pode receber qualquer quantidade de entradas, por\u00e9m espera-se que sejam dos tipos: \nstr\n, \nint\n e a pr\u00f3pria classe \nRegex\n. Para entender melhor:\n\n\n\n\nstr\n: concatena \u00e0 vari\u00e1vel \nself.rgx\n;\n\n\nint\n: realiza \nbackreferences\n;\n\n\nRegex\n: concatena o valor armazenado em \nself.rgx\n do objeto que se recebe na vari\u00e1vel \nself.rgx\n do objeto que est\u00e1 recebendo.\n\n\n\n\nFormas de se declarar um \nRegex\n:\n\n\nfrom mre import Regex, Group\n\nrgx_one = Regex(\"Hello world\")  # Hello world\nrgx_two = Regex(\"Hello\", \" world\")  # Hello world\nrgx_three = Regex(\"Hello\") + \" \" + Regex(\"world\")  # Hello world\nrgx_four = Regex('<', Group('h[1-6]'), '>')  # <(h[1-6])>\nrgx_five = Regex('<', Regex.SLASH, 1, '>')  # <\\/\\1>\n\n\n\n\nConstantes\n\n\nConstantes presentes na classe \nRegex\n:\n\n\n\n\n\n\n\n\nConstante\n\n\nValor\n\n\n\n\n\n\n\n\n\n\nANY\n\n\n.\n\n\n\n\n\n\nDOT\n\n\n\\\\.\n\n\n\n\n\n\nDIGIT\n\n\n\\\\d\n\n\n\n\n\n\nWHITESPACE\n\n\n\\\\s\n\n\n\n\n\n\nWORD_CHARS\n\n\n\\\\w\n\n\n\n\n\n\nSLASH\n\n\n\\\\/.\n\n\n\n\n\n\nNOT_DIGIT\n\n\n\\\\D\n\n\n\n\n\n\nNOT_WHITESPACE\n\n\n\\\\S\n\n\n\n\n\n\nNOT_WORD_CHARS\n\n\n\\\\W\n\n\n\n\n\n\nZERO_OR_ONE\n\n\n?\n\n\n\n\n\n\nZERO_OR_MULTIPLE\n\n\n*\n\n\n\n\n\n\nONE_OR_MULTIPLE\n\n\n+\n\n\n\n\n\n\nHYPHEN\n\n\n\\\\-\n\n\n\n\n\n\n\n\nM\u00e9todos\n\n\nAl\u00e9m das fun\u00e7\u00f5es, tamb\u00e9m haver\u00e1 a descri\u00e7\u00e3o das sobrecargas.\n\n\n__str__\n\n\nRetorna o valor salvo em \nself.rgx\n.\n\n\nfrom mre import Regex\n\nregex = Regex(\"Hello world\")\nprint(regex)  # \"Hello world\"\n\n\n\n\n__eq__\n\n\nA compara\u00e7\u00e3o pode ser entre \nstr\n ou \nRegex\n:\n- \n== str\n: compara \nself.rgx\n ao valor da vari\u00e1vel recebida;\n- \n== Regex\n: compara \nself.rgx\n (acessado atrav\u00e9s do m\u00e9todo \nget\n) ao valor da vari\u00e1vel \nself.rgx\n do objeto recebido (tamb\u00e9m acessado atrav\u00e9s do m\u00e9todo \nget\n).\n\n\nfrom mre import Regex\n\nregex_one = Regex(\"Hello world\")\n\nprint(regex_one == \"Hello world\")  # True\nprint(regex_one == \"Hello world!\")  # False\n\nprint(regex_one == Regex(\"Hello world\"))  # True\nprint(regex_one == Regex(\"Hello world!\"))  # False\n\n\n\n\n__iadd__\n\n\nEspera-se vari\u00e1veis de dois tipos: \nstr\n e \nRegex\n. Para entender melhor:\n\n\n\n\n+= str\n: concatena \nself.rgx\n ao valor da vari\u00e1vel recebida;\n\n\n+= Regex\n: concatena \nself.rgx\n ao valor da vari\u00e1vel \nself.rgx\n do objeto recebido (acessado atrav\u00e9s do m\u00e9todo \nget\n).\n\n\n\n\nEssa sobrecarga altera diretamente a vari\u00e1vel \nself.rgx\n, sendo assim nos casos de opera\u00e7\u00e3o, por exemplo, em um objeto \nSet\n, ir\u00e1 alterar o valor entre os colchetes.\n\n\nfrom mre import Regex, Set\n\nregex = Regex(\"Hello\")\nregex += \" world\"\nprint(regex)  # \"Hello world\"\n\nregex_set = Set(\"Hello\")  # [Hello]\nregex_set += \" world\"\nprint(regex_set)  # \"[Hello world]\"\n\n\n\n\n__add__\n\n\nEspera-se vari\u00e1veis de dois tipos: \nstr\n e \nRegex\n. Diferentemente da sobrecarga \n__iadd__\n, essa sobrecarga retorna um novo objeto \nRegex\n.\n\n\n\n\n+ str\n: concatena \nself.rgx\n (acessado atrav\u00e9s do m\u00e9todo \nget\n) ao valor da vari\u00e1vel recebida;\n\n\n+ Regex\n: concatena \nself.rgx\n (acessado atrav\u00e9s do m\u00e9todo \nget\n) ao valor da vari\u00e1vel \nself.rgx\n do objeto recebido (tamb\u00e9m acessado atrav\u00e9s do m\u00e9todo \nget\n).\n\n\n\n\nfrom mre import Regex\n\nregex_one = Regex(\"Hello\") + \" \" + Regex(\"world\")\nregex_two = Regex(\"Hello\") + Regex(\" world\")\n\nprint(regex_one)  # \"Hello world\"\nprint(regex_two)  # \"Hello world\"\n\n\n\n\nget\n\n\nRetorna o valor armazenado em \nself.rgx\n.\n\n\nfrom mre import Regex\n\nregex = Regex(\"Valor armazenado\")\nprint(regex.get())  # \"Valor armazenado\"\n\n\n\n\nquantifier\n\n\nPossui os seguintes par\u00e2metros:\n\n\n\n\n\n\n\n\nPar\u00e2metro\n\n\nTipo\n\n\nValor padr\u00e3o\n\n\n\n\n\n\n\n\n\n\nn\n\n\nint\n\n\n0\n\n\n\n\n\n\nm\n\n\nint\n\n\n0\n\n\n\n\n\n\nwithout_maximum\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nServe para quantificar as vezes que o RegEx deve/pode aparecer (de \nn\n at\u00e9 \nm\n). Retorna um novo objeto \nRegex\n.\n\n\nEm casos espec\u00edficos, h\u00e1 a adi\u00e7\u00e3o de um s\u00edmbolo. Esses casos s\u00e3o:\n\n\n\n\n\n\n\n\nn\n\n\nm\n\n\nwithout_maximum\n\n\nS\u00edmbolo\n\n\nAcesso\n\n\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n-\n\n\n?\n\n\nRegex.ZERO_OR_ONE\n\n\n\n\n\n\n0\n\n\n-\n\n\nTrue\n\n\n*\n\n\nRegex.ZERO_OR_MULTIPLE\n\n\n\n\n\n\n1\n\n\n-\n\n\nTrue\n\n\n+\n\n\nRegex.ONE_OR_MULTIPLE\n\n\n\n\n\n\n\n\nAl\u00e9m desses casos espec\u00edficos, a quantifica\u00e7\u00e3o poder\u00e1 ocorrer das formas:\n- \n{n}\n: deve ocorrer \nn\n vezes;\n- \n{n, m}\n: pode ocorrer de \nn\n at\u00e9 \nm\n vezes.\n\n\nfrom mre import Regex\n\ndigits = Regex(\"[0-9]\")\n\nprint(digits.quantifier(3))  # \"[0-9]{3}\"\nprint(digits.quantifier(3, 5))  # \"[0-9]{3,5}\"\nprint(digits.quantifier(0, 1))  # \"[0-9]?\"\nprint(digits.quantifier(0, without_maximum=True))  # \"[0-9]*\"\nprint(digits.quantifier(1, without_maximum=True))  # \"[0-9]+\"\n\n\n\n\nbackreferences\n\n\nPossui um par\u00e2metro do tipo \nint\n (\ngroup_n\n) que serve para indicar qual grupo se deseja realizar a \nbackreference\n. Retorna um \nRegex\n que realiza \nbackreferences\n ao grupo indicado.\n\n\nUm meio alternativo de chamar esse m\u00e9todo \u00e9 inserindo um \nint\n no construtor.\n\n\nfrom mre import Regex\n\nregex_one = Regex().backreferences(1)\nregex_two = Regex(2)\n\nprint(regex_one)  # \"\\1\"\nprint(regex_two)  # \"\\2\"\n\n\n\n\nQuantifier\n\n\nEssa classe serve como uma alternativa a chamada do m\u00e9todo \nRegex.quantifier\n. Seu construtor recebe 4 par\u00e2metros:\n\n\n\n\n\n\n\n\nPar\u00e2metro\n\n\nTipo\n\n\nValor padr\u00e3o\n\n\n\n\n\n\n\n\n\n\nregex\n\n\nstr\n, \nint\n, \nRegex\n\n\n\"\"\n\n\n\n\n\n\nn\n\n\nint\n\n\n0\n\n\n\n\n\n\nm\n\n\nint\n\n\n0\n\n\n\n\n\n\nwithout_maximum\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nO primeiro \u00e9 referente ao RegEx que se deseja construir, os 3 restantes s\u00e3o para a chamada do m\u00e9todo \nRegex.quantifier\n.\n\n\nfrom mre import Regex, Quantifier\n\ndigits_one = Regex(\"[0-9]\").quantifier(3, 5)\ndigits_two = Quantifier(\"[0-9]\", 3, 5)\n\nprint(digits_one)  # \"[0-9]{3,5}\"\nprint(digits_two)  # \"[0-9]{3,5}\"\n\n\n\n\nSet\n\n\nEssa classe representa um conjunto no RegEx. Seu construtor \u00e9 o mesmo da classe \nRegex\n.\n\n\nfrom mre import Set\n\nregex_set = Set(\"0-9\")\n\nprint(regex_set)  # \"[0-9]\"\nprint(regex_set.quantifier(3))  # \"[0-9]{3}\"\n\n\n\n\nM\u00e9todos\n\n\nEssa classe herda os m\u00e9todos da classe \nRegex\n, sobrescrevendo apenas os m\u00e9todos a seguir.\n\n\nget\n\n\nRetorna o valor armazenado em \nself.rgx\n, mas entre colchetes.\n\n\nfrom mre import Set\n\nregex_set = Set(\"0-9\")\nprint(regex_set.get())  # \"[0-9]\"\n\n\n\n\nquantifier\n\n\nRetorna um novo objeto \nRegex\n com o quantificador referente ao conjunto.\n\n\nfrom mre import Set\n\nregex_set = Set(\"0-9\")\n\nprint(regex_set)  # \"[0-9]\"\nprint(regex_set.quantifier(3))  # \"[0-9]{3}\"\n\nprint(type(regex_set))  # <class 'mre.Set.Set'>\nprint(type(regex_set.quantifier(3)))  # <class 'mre.Regex.Regex'>\n\n\n\n\nGroup\n\n\nEssa classe representa um grupo no RegEx. Seu construtor recebe 2 par\u00e2metros:\n\n\n\n\n\n\n\n\nPar\u00e2metro\n\n\nTipo\n\n\nValor padr\u00e3o\n\n\n\n\n\n\n\n\n\n\nregex\n\n\nstr\n, \nint\n, \nRegex\n\n\n\"\"\n\n\n\n\n\n\nnon_capturing\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nSe o argumento referente a \nnon_capturing\n for \nTrue\n, ser\u00e1 adicionado os s\u00edmbolos que indicam que a \nRegEx Engine\n n\u00e3o deve retornar o valor daquele grupo (\n?:\n).\n\n\nfrom mre import Group\n\nregex_group_one = Group('<h1>') + Group('[\\w\\s]+') + Group('</h1>')\nregex_group_two = Group('<h1>', True) + Group('[\\w\\s]+') + Group('</h1>', True)\n\nprint(regex_group_one)  # (<h1>)([\\w\\s]+)(</h1>)\nprint(regex_group_two)  # (?:<h1>)([\\w\\s]+)(?:</h1>)\n\n\n\n\nM\u00e9todos\n\n\nEssa classe herda os m\u00e9todos da classe \nRegex\n, sobrescrevendo apenas os m\u00e9todos a seguir.\n\n\nget\n\n\nRetorna o valor armazenado em \nself.rgx\n, mas entre par\u00eanteses.\n\n\nfrom mre import Group\n\nregex_group_one = Group(\"<h1>\")\nregex_group_two = Group(\"</h1>\", True)\n\nprint(regex_group_one.get())  # \"(<h1>)\"\nprint(regex_group_two.get())  # \"(?:</h1>)\"\n\n\n\n\nquantifier\n\n\nRetorna um novo objeto \nRegex\n com o quantificador referente ao grupo.\n\n\nfrom mre import Group\n\nregex_group = Group(\"<h1>\")\n\nprint(regex_group)  # \"(<h1>)\"\nprint(regex_group.quantifier(3))  # \"(<h1>){3}\"\n\nprint(type(regex_group))  # <class 'mre.Group.Group'>\nprint(type(regex_group.quantifier(3)))  # <class 'mre.Regex.Regex'>\n\n\n\n\nAnchor\n\n\nEssa classe representa um RegEx com \u00e2ncora (o RegEx deve come\u00e7ar e terminar como foi definido). Seu construtor recebe 2 par\u00e2metros:\n\n\n\n\n\n\n\n\nPar\u00e2metro\n\n\nTipo\n\n\nValor padr\u00e3o\n\n\n\n\n\n\n\n\n\n\nregex\n\n\nstr\n, \nint\n, \nRegex\n\n\n\"\"\n\n\n\n\n\n\nnegate\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nSe o argumento referente a \nnegate\n for \nTrue\n, ser\u00e1 adicionado os s\u00edmbolos do inverso do padr\u00e3o, ou seja, a RegEx n\u00e3o deve come\u00e7ar e terminar como definido.\n\n\nfrom mre import Anchor\n\nregex_anchor_one = Anchor(\"\\\\d{4}-\\\\w+.txt\")\nregex_anchor_two = Anchor(\"\\\\d{4}-\\\\w+.txt\", True)\n\nprint(regex_anchor_one)  # \"^\\d{4}-\\w+.txt$\"\nprint(regex_anchor_two)  # \"\\b\\d{4}-\\w+.txt\\B\"\n\n\n\n\nM\u00e9todos\n\n\nEssa classe herda os m\u00e9todos da classe \nRegex\n, sobrescrevendo apenas os m\u00e9todos a seguir.\n\n\nget\n\n\nRetorna o valor armazenado em \nself.rgx\n, mas entre par\u00eanteses.\n\n\nfrom mre import Anchor\n\nregex_anchor_one = Anchor(\"<h1>Hello world<\\/h1>\")\nregex_anchor_two = Anchor(\"<h1>Hello world<\\/h1>\", True)\n\nprint(regex_anchor_one.get())  # \"^<h1>Hello world</h1>$\"\nprint(regex_anchor_two.get())  # \"\\b<h1>Hello world</h1>\\B\"\n\n\n\n\nhelper.Range\n\n\nEssa classe serve para ajudar na cria\u00e7\u00e3o de um RegEx que indique uma classe de caracteres a partir de um \nrange\n. Seu construtor recebe 2 par\u00e2metros:\n\n\n\n\n\n\n\n\nPar\u00e2metro\n\n\nTipo\n\n\nValor padr\u00e3o\n\n\n\n\n\n\n\n\n\n\nminimum\n\n\nstr\n, \nint\n\n\n0\n\n\n\n\n\n\nmaximum\n\n\nstr\n, \nint\n\n\n\"z\"\n\n\n\n\n\n\n\n\nIdealmente usar essa classe junto a classe \nSet\n, pois dentro de um conjunto, o h\u00edfen possui um valor \"m\u00e1gico\" que o permite dar essa fun\u00e7\u00e3o de atribuir \nrange\n, fora do conjunto o h\u00edfen tem apenas valor de h\u00edfen. Logo, se voc\u00ea quiser, por exemplo, todas as letras min\u00fasculas, deve usar \n[a-z]\n e n\u00e3o apenas \na-z\n, pois assim voc\u00ea est\u00e1 apenas dizendo que quer \na\n, \n-\n e \nz\n.\n\n\nfrom mre.helper import Range\n\n# Todos os d\u00edgitos\ndigits = Range(0, 9)\n# Todas as letras\nletters = Range('A', 'z')\n\nprint(digits)  # \"0-9\"\nprint(letters)  # \"A-z\"\n\n\n\n\nM\u00e9todos\n\n\nEssa classe herda os m\u00e9todos da classe \nRegex\n, al\u00e9m de possuir seus pr\u00f3prios m\u00e9todos.\n\n\ndigits\n\n\nPossui 2 par\u00e2metros:\n\n\n\n\n\n\n\n\nPar\u00e2metro\n\n\nTipo\n\n\nValor padr\u00e3o\n\n\n\n\n\n\n\n\n\n\nminimum\n\n\nint\n\n\n0\n\n\n\n\n\n\nmaximum\n\n\nint\n\n\n9\n\n\n\n\n\n\n\n\nRetorna um \nrange\n que define os d\u00edgitos entre \nminimum\n e \nmaximum\n.\n\n\nfrom mre.helper import Range\n\nregex_range_one = Range(0, 9)\nregex_range_two = Range().digits()\nregex_range_three = Range(0, 6)\nregex_range_four = Range().digits(0, 6)\n\nprint(regex_range_one)  # \"0-9\"\nprint(regex_range_two)  # \"0-9\"\nprint(regex_range_three)  # \"0-6\"\nprint(regex_range_four)  # \"0-6\"\n\n\n\n\nletters\n\n\nPossui 4 par\u00e2metros:\n\n\n\n\n\n\n\n\nPar\u00e2metro\n\n\nTipo\n\n\nValor padr\u00e3o\n\n\n\n\n\n\n\n\n\n\nminimum\n\n\nchr\n\n\nA\n\n\n\n\n\n\nmaximum\n\n\nchr\n\n\nz\n\n\n\n\n\n\nuppercase\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\nlowercase\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nRetorna um \nrange\n que define as letras entre \nminimum\n e \nmaximum\n.\n\n\nfrom mre.helper import Range\n\n# Todas as letras\nregex_range_one = Range('A', 'z')\nregex_range_two = Range().letters()\nregex_range_three = Range().letters('A', 'z')\nregex_range_four = Range().letters(uppercase=True, lowercase=True)\n# Todas as letras mai\u00fasculas\nregex_range_five = Range().letters(uppercase=True)\n# Todas as letras min\u00fasculas\nregex_range_six = Range().letters(lowercase=True)\n\nprint(regex_range_one)  # \"A-z\"\nprint(regex_range_two)  # \"A-z\"\nprint(regex_range_three)  # \"A-z\"\nprint(regex_range_four)  # \"A-z\"\nprint(regex_range_five)  # \"A-Z\"\nprint(regex_range_six)  # \"a-z\"\n\n\n\n\nExemplos\n\n\n2 formas de fazer o RegEx de \nCEP\n (\n[0-9]{5}-?[0-9]{3}\n)\n\n\nfrom mre import Regex, Set\n\n# Todos os d\u00edgitos\ndigits = Set(Regex(\"0-9\"))\n\nrgx_cep = Regex(\n    digits.quantifier(5),\n    Regex(\"-\").quantifier(0, 1),\n    digits.quantifier(3),\n)\n\n\n\n\nfrom mre import Regex, Quantifier, Set\nfrom mre.helper import Range\n\n# Todos os d\u00edgitos [0-9]\ndigits = Set(Range().digits())\n# O h\u00edfen pode aparecer nenhuma ou uma vez\nhyphen = Quantifier(\"-\", 0, 1)\n\nrgx_cep = Regex(\n    digits.quantifier(5), hyphen,\n    digits.quantifier(3),\n)\n\n\n\n\nRegEx de \nCPF\n (\n[0-9]{3}.?[0-9]{3}.?[0-9]{3}-?[0-9]{2}\n):\n\n\nfrom mre import Regex, Set\nfrom mre.helper import Range\n\n# Todos os d\u00edgitos\nall_digits = Set(Range(0, 9))\n# O ponto pode aparecer nenhuma ou uma vez\ndot = Regex(Regex.DOT).quantifier(0, 1)\n# O h\u00edfen pode aparecer nenhuma ou uma vez\nhyphen = Regex('-').quantifier(0, 1)\n\nrgx_cpf = Regex(\n    all_digits.quantifier(3), dot,\n    all_digits.quantifier(3), dot,\n    all_digits.quantifier(3), hyphen,\n    all_digits.quantifier(2),\n)\n\n\n\n\nRegEx de \nCNPJ\n (\n\\d{2}\\.?\\d{3}\\.?\\d{3}\\/?\\d{4}\\-?\\d{2}\n):\n\n\nfrom mre import Regex, Quantifier\n\n# Todos os d\u00edgitos\ndigits = Regex(Regex.DIGIT)\n# O ponto pode aparecer nenhuma ou uma vez\ndot = Regex(Regex.DOT).quantifier(0, 1)\n# A barra pode aparecer nenhuma ou uma vez\nslash = Regex(Regex.SLASH).quantifier(0, 1)\n# O h\u00edfen pode aparecer nenhuma ou uma vez\nhyphen = Quantifier(\"-\", 0, 1)\n\nrgx_cnpj = Regex(\n    digits.quantifier(2), dot,\n    digits.quantifier(3), dot,\n    digits.quantifier(3), slash,\n    digits.quantifier(4), hyphen,\n    digits.quantifier(2),\n)",
            "title": "Guia de uso"
        },
        {
            "location": "/pt_BR/guia-de-uso/#classes",
            "text": "Regex  Quantifier  Set  Group  Anchor  Helper  Range",
            "title": "Classes"
        },
        {
            "location": "/pt_BR/guia-de-uso/#regex",
            "text": "Essa \u00e9 a classe pai de todas as classes do pacote, o RegEx que se est\u00e1 manipulando fica na vari\u00e1vel  self.rgx . Seu construtor pode receber qualquer quantidade de entradas, por\u00e9m espera-se que sejam dos tipos:  str ,  int  e a pr\u00f3pria classe  Regex . Para entender melhor:   str : concatena \u00e0 vari\u00e1vel  self.rgx ;  int : realiza  backreferences ;  Regex : concatena o valor armazenado em  self.rgx  do objeto que se recebe na vari\u00e1vel  self.rgx  do objeto que est\u00e1 recebendo.   Formas de se declarar um  Regex :  from mre import Regex, Group\n\nrgx_one = Regex(\"Hello world\")  # Hello world\nrgx_two = Regex(\"Hello\", \" world\")  # Hello world\nrgx_three = Regex(\"Hello\") + \" \" + Regex(\"world\")  # Hello world\nrgx_four = Regex('<', Group('h[1-6]'), '>')  # <(h[1-6])>\nrgx_five = Regex('<', Regex.SLASH, 1, '>')  # <\\/\\1>",
            "title": "Regex"
        },
        {
            "location": "/pt_BR/guia-de-uso/#constantes",
            "text": "Constantes presentes na classe  Regex :     Constante  Valor      ANY  .    DOT  \\\\.    DIGIT  \\\\d    WHITESPACE  \\\\s    WORD_CHARS  \\\\w    SLASH  \\\\/.    NOT_DIGIT  \\\\D    NOT_WHITESPACE  \\\\S    NOT_WORD_CHARS  \\\\W    ZERO_OR_ONE  ?    ZERO_OR_MULTIPLE  *    ONE_OR_MULTIPLE  +    HYPHEN  \\\\-",
            "title": "Constantes"
        },
        {
            "location": "/pt_BR/guia-de-uso/#metodos",
            "text": "Al\u00e9m das fun\u00e7\u00f5es, tamb\u00e9m haver\u00e1 a descri\u00e7\u00e3o das sobrecargas.",
            "title": "M\u00e9todos"
        },
        {
            "location": "/pt_BR/guia-de-uso/#9595str9595",
            "text": "Retorna o valor salvo em  self.rgx .  from mre import Regex\n\nregex = Regex(\"Hello world\")\nprint(regex)  # \"Hello world\"",
            "title": "__str__"
        },
        {
            "location": "/pt_BR/guia-de-uso/#9595eq9595",
            "text": "A compara\u00e7\u00e3o pode ser entre  str  ou  Regex :\n-  == str : compara  self.rgx  ao valor da vari\u00e1vel recebida;\n-  == Regex : compara  self.rgx  (acessado atrav\u00e9s do m\u00e9todo  get ) ao valor da vari\u00e1vel  self.rgx  do objeto recebido (tamb\u00e9m acessado atrav\u00e9s do m\u00e9todo  get ).  from mre import Regex\n\nregex_one = Regex(\"Hello world\")\n\nprint(regex_one == \"Hello world\")  # True\nprint(regex_one == \"Hello world!\")  # False\n\nprint(regex_one == Regex(\"Hello world\"))  # True\nprint(regex_one == Regex(\"Hello world!\"))  # False",
            "title": "__eq__"
        },
        {
            "location": "/pt_BR/guia-de-uso/#9595iadd9595",
            "text": "Espera-se vari\u00e1veis de dois tipos:  str  e  Regex . Para entender melhor:   += str : concatena  self.rgx  ao valor da vari\u00e1vel recebida;  += Regex : concatena  self.rgx  ao valor da vari\u00e1vel  self.rgx  do objeto recebido (acessado atrav\u00e9s do m\u00e9todo  get ).   Essa sobrecarga altera diretamente a vari\u00e1vel  self.rgx , sendo assim nos casos de opera\u00e7\u00e3o, por exemplo, em um objeto  Set , ir\u00e1 alterar o valor entre os colchetes.  from mre import Regex, Set\n\nregex = Regex(\"Hello\")\nregex += \" world\"\nprint(regex)  # \"Hello world\"\n\nregex_set = Set(\"Hello\")  # [Hello]\nregex_set += \" world\"\nprint(regex_set)  # \"[Hello world]\"",
            "title": "__iadd__"
        },
        {
            "location": "/pt_BR/guia-de-uso/#9595add9595",
            "text": "Espera-se vari\u00e1veis de dois tipos:  str  e  Regex . Diferentemente da sobrecarga  __iadd__ , essa sobrecarga retorna um novo objeto  Regex .   + str : concatena  self.rgx  (acessado atrav\u00e9s do m\u00e9todo  get ) ao valor da vari\u00e1vel recebida;  + Regex : concatena  self.rgx  (acessado atrav\u00e9s do m\u00e9todo  get ) ao valor da vari\u00e1vel  self.rgx  do objeto recebido (tamb\u00e9m acessado atrav\u00e9s do m\u00e9todo  get ).   from mre import Regex\n\nregex_one = Regex(\"Hello\") + \" \" + Regex(\"world\")\nregex_two = Regex(\"Hello\") + Regex(\" world\")\n\nprint(regex_one)  # \"Hello world\"\nprint(regex_two)  # \"Hello world\"",
            "title": "__add__"
        },
        {
            "location": "/pt_BR/guia-de-uso/#get",
            "text": "Retorna o valor armazenado em  self.rgx .  from mre import Regex\n\nregex = Regex(\"Valor armazenado\")\nprint(regex.get())  # \"Valor armazenado\"",
            "title": "get"
        },
        {
            "location": "/pt_BR/guia-de-uso/#quantifier",
            "text": "Possui os seguintes par\u00e2metros:     Par\u00e2metro  Tipo  Valor padr\u00e3o      n  int  0    m  int  0    without_maximum  bool  False     Serve para quantificar as vezes que o RegEx deve/pode aparecer (de  n  at\u00e9  m ). Retorna um novo objeto  Regex .  Em casos espec\u00edficos, h\u00e1 a adi\u00e7\u00e3o de um s\u00edmbolo. Esses casos s\u00e3o:     n  m  without_maximum  S\u00edmbolo  Acesso      0  1  -  ?  Regex.ZERO_OR_ONE    0  -  True  *  Regex.ZERO_OR_MULTIPLE    1  -  True  +  Regex.ONE_OR_MULTIPLE     Al\u00e9m desses casos espec\u00edficos, a quantifica\u00e7\u00e3o poder\u00e1 ocorrer das formas:\n-  {n} : deve ocorrer  n  vezes;\n-  {n, m} : pode ocorrer de  n  at\u00e9  m  vezes.  from mre import Regex\n\ndigits = Regex(\"[0-9]\")\n\nprint(digits.quantifier(3))  # \"[0-9]{3}\"\nprint(digits.quantifier(3, 5))  # \"[0-9]{3,5}\"\nprint(digits.quantifier(0, 1))  # \"[0-9]?\"\nprint(digits.quantifier(0, without_maximum=True))  # \"[0-9]*\"\nprint(digits.quantifier(1, without_maximum=True))  # \"[0-9]+\"",
            "title": "quantifier"
        },
        {
            "location": "/pt_BR/guia-de-uso/#backreferences",
            "text": "Possui um par\u00e2metro do tipo  int  ( group_n ) que serve para indicar qual grupo se deseja realizar a  backreference . Retorna um  Regex  que realiza  backreferences  ao grupo indicado.  Um meio alternativo de chamar esse m\u00e9todo \u00e9 inserindo um  int  no construtor.  from mre import Regex\n\nregex_one = Regex().backreferences(1)\nregex_two = Regex(2)\n\nprint(regex_one)  # \"\\1\"\nprint(regex_two)  # \"\\2\"",
            "title": "backreferences"
        },
        {
            "location": "/pt_BR/guia-de-uso/#quantifier_1",
            "text": "Essa classe serve como uma alternativa a chamada do m\u00e9todo  Regex.quantifier . Seu construtor recebe 4 par\u00e2metros:     Par\u00e2metro  Tipo  Valor padr\u00e3o      regex  str ,  int ,  Regex  \"\"    n  int  0    m  int  0    without_maximum  bool  False     O primeiro \u00e9 referente ao RegEx que se deseja construir, os 3 restantes s\u00e3o para a chamada do m\u00e9todo  Regex.quantifier .  from mre import Regex, Quantifier\n\ndigits_one = Regex(\"[0-9]\").quantifier(3, 5)\ndigits_two = Quantifier(\"[0-9]\", 3, 5)\n\nprint(digits_one)  # \"[0-9]{3,5}\"\nprint(digits_two)  # \"[0-9]{3,5}\"",
            "title": "Quantifier"
        },
        {
            "location": "/pt_BR/guia-de-uso/#set",
            "text": "Essa classe representa um conjunto no RegEx. Seu construtor \u00e9 o mesmo da classe  Regex .  from mre import Set\n\nregex_set = Set(\"0-9\")\n\nprint(regex_set)  # \"[0-9]\"\nprint(regex_set.quantifier(3))  # \"[0-9]{3}\"",
            "title": "Set"
        },
        {
            "location": "/pt_BR/guia-de-uso/#metodos_1",
            "text": "Essa classe herda os m\u00e9todos da classe  Regex , sobrescrevendo apenas os m\u00e9todos a seguir.",
            "title": "M\u00e9todos"
        },
        {
            "location": "/pt_BR/guia-de-uso/#get_1",
            "text": "Retorna o valor armazenado em  self.rgx , mas entre colchetes.  from mre import Set\n\nregex_set = Set(\"0-9\")\nprint(regex_set.get())  # \"[0-9]\"",
            "title": "get"
        },
        {
            "location": "/pt_BR/guia-de-uso/#quantifier_2",
            "text": "Retorna um novo objeto  Regex  com o quantificador referente ao conjunto.  from mre import Set\n\nregex_set = Set(\"0-9\")\n\nprint(regex_set)  # \"[0-9]\"\nprint(regex_set.quantifier(3))  # \"[0-9]{3}\"\n\nprint(type(regex_set))  # <class 'mre.Set.Set'>\nprint(type(regex_set.quantifier(3)))  # <class 'mre.Regex.Regex'>",
            "title": "quantifier"
        },
        {
            "location": "/pt_BR/guia-de-uso/#group",
            "text": "Essa classe representa um grupo no RegEx. Seu construtor recebe 2 par\u00e2metros:     Par\u00e2metro  Tipo  Valor padr\u00e3o      regex  str ,  int ,  Regex  \"\"    non_capturing  bool  False     Se o argumento referente a  non_capturing  for  True , ser\u00e1 adicionado os s\u00edmbolos que indicam que a  RegEx Engine  n\u00e3o deve retornar o valor daquele grupo ( ?: ).  from mre import Group\n\nregex_group_one = Group('<h1>') + Group('[\\w\\s]+') + Group('</h1>')\nregex_group_two = Group('<h1>', True) + Group('[\\w\\s]+') + Group('</h1>', True)\n\nprint(regex_group_one)  # (<h1>)([\\w\\s]+)(</h1>)\nprint(regex_group_two)  # (?:<h1>)([\\w\\s]+)(?:</h1>)",
            "title": "Group"
        },
        {
            "location": "/pt_BR/guia-de-uso/#metodos_2",
            "text": "Essa classe herda os m\u00e9todos da classe  Regex , sobrescrevendo apenas os m\u00e9todos a seguir.",
            "title": "M\u00e9todos"
        },
        {
            "location": "/pt_BR/guia-de-uso/#get_2",
            "text": "Retorna o valor armazenado em  self.rgx , mas entre par\u00eanteses.  from mre import Group\n\nregex_group_one = Group(\"<h1>\")\nregex_group_two = Group(\"</h1>\", True)\n\nprint(regex_group_one.get())  # \"(<h1>)\"\nprint(regex_group_two.get())  # \"(?:</h1>)\"",
            "title": "get"
        },
        {
            "location": "/pt_BR/guia-de-uso/#quantifier_3",
            "text": "Retorna um novo objeto  Regex  com o quantificador referente ao grupo.  from mre import Group\n\nregex_group = Group(\"<h1>\")\n\nprint(regex_group)  # \"(<h1>)\"\nprint(regex_group.quantifier(3))  # \"(<h1>){3}\"\n\nprint(type(regex_group))  # <class 'mre.Group.Group'>\nprint(type(regex_group.quantifier(3)))  # <class 'mre.Regex.Regex'>",
            "title": "quantifier"
        },
        {
            "location": "/pt_BR/guia-de-uso/#anchor",
            "text": "Essa classe representa um RegEx com \u00e2ncora (o RegEx deve come\u00e7ar e terminar como foi definido). Seu construtor recebe 2 par\u00e2metros:     Par\u00e2metro  Tipo  Valor padr\u00e3o      regex  str ,  int ,  Regex  \"\"    negate  bool  False     Se o argumento referente a  negate  for  True , ser\u00e1 adicionado os s\u00edmbolos do inverso do padr\u00e3o, ou seja, a RegEx n\u00e3o deve come\u00e7ar e terminar como definido.  from mre import Anchor\n\nregex_anchor_one = Anchor(\"\\\\d{4}-\\\\w+.txt\")\nregex_anchor_two = Anchor(\"\\\\d{4}-\\\\w+.txt\", True)\n\nprint(regex_anchor_one)  # \"^\\d{4}-\\w+.txt$\"\nprint(regex_anchor_two)  # \"\\b\\d{4}-\\w+.txt\\B\"",
            "title": "Anchor"
        },
        {
            "location": "/pt_BR/guia-de-uso/#metodos_3",
            "text": "Essa classe herda os m\u00e9todos da classe  Regex , sobrescrevendo apenas os m\u00e9todos a seguir.",
            "title": "M\u00e9todos"
        },
        {
            "location": "/pt_BR/guia-de-uso/#get_3",
            "text": "Retorna o valor armazenado em  self.rgx , mas entre par\u00eanteses.  from mre import Anchor\n\nregex_anchor_one = Anchor(\"<h1>Hello world<\\/h1>\")\nregex_anchor_two = Anchor(\"<h1>Hello world<\\/h1>\", True)\n\nprint(regex_anchor_one.get())  # \"^<h1>Hello world</h1>$\"\nprint(regex_anchor_two.get())  # \"\\b<h1>Hello world</h1>\\B\"",
            "title": "get"
        },
        {
            "location": "/pt_BR/guia-de-uso/#helperrange",
            "text": "Essa classe serve para ajudar na cria\u00e7\u00e3o de um RegEx que indique uma classe de caracteres a partir de um  range . Seu construtor recebe 2 par\u00e2metros:     Par\u00e2metro  Tipo  Valor padr\u00e3o      minimum  str ,  int  0    maximum  str ,  int  \"z\"     Idealmente usar essa classe junto a classe  Set , pois dentro de um conjunto, o h\u00edfen possui um valor \"m\u00e1gico\" que o permite dar essa fun\u00e7\u00e3o de atribuir  range , fora do conjunto o h\u00edfen tem apenas valor de h\u00edfen. Logo, se voc\u00ea quiser, por exemplo, todas as letras min\u00fasculas, deve usar  [a-z]  e n\u00e3o apenas  a-z , pois assim voc\u00ea est\u00e1 apenas dizendo que quer  a ,  -  e  z .  from mre.helper import Range\n\n# Todos os d\u00edgitos\ndigits = Range(0, 9)\n# Todas as letras\nletters = Range('A', 'z')\n\nprint(digits)  # \"0-9\"\nprint(letters)  # \"A-z\"",
            "title": "helper.Range"
        },
        {
            "location": "/pt_BR/guia-de-uso/#metodos_4",
            "text": "Essa classe herda os m\u00e9todos da classe  Regex , al\u00e9m de possuir seus pr\u00f3prios m\u00e9todos.",
            "title": "M\u00e9todos"
        },
        {
            "location": "/pt_BR/guia-de-uso/#digits",
            "text": "Possui 2 par\u00e2metros:     Par\u00e2metro  Tipo  Valor padr\u00e3o      minimum  int  0    maximum  int  9     Retorna um  range  que define os d\u00edgitos entre  minimum  e  maximum .  from mre.helper import Range\n\nregex_range_one = Range(0, 9)\nregex_range_two = Range().digits()\nregex_range_three = Range(0, 6)\nregex_range_four = Range().digits(0, 6)\n\nprint(regex_range_one)  # \"0-9\"\nprint(regex_range_two)  # \"0-9\"\nprint(regex_range_three)  # \"0-6\"\nprint(regex_range_four)  # \"0-6\"",
            "title": "digits"
        },
        {
            "location": "/pt_BR/guia-de-uso/#letters",
            "text": "Possui 4 par\u00e2metros:     Par\u00e2metro  Tipo  Valor padr\u00e3o      minimum  chr  A    maximum  chr  z    uppercase  bool  False    lowercase  bool  False     Retorna um  range  que define as letras entre  minimum  e  maximum .  from mre.helper import Range\n\n# Todas as letras\nregex_range_one = Range('A', 'z')\nregex_range_two = Range().letters()\nregex_range_three = Range().letters('A', 'z')\nregex_range_four = Range().letters(uppercase=True, lowercase=True)\n# Todas as letras mai\u00fasculas\nregex_range_five = Range().letters(uppercase=True)\n# Todas as letras min\u00fasculas\nregex_range_six = Range().letters(lowercase=True)\n\nprint(regex_range_one)  # \"A-z\"\nprint(regex_range_two)  # \"A-z\"\nprint(regex_range_three)  # \"A-z\"\nprint(regex_range_four)  # \"A-z\"\nprint(regex_range_five)  # \"A-Z\"\nprint(regex_range_six)  # \"a-z\"",
            "title": "letters"
        },
        {
            "location": "/pt_BR/guia-de-uso/#exemplos",
            "text": "2 formas de fazer o RegEx de  CEP  ( [0-9]{5}-?[0-9]{3} )  from mre import Regex, Set\n\n# Todos os d\u00edgitos\ndigits = Set(Regex(\"0-9\"))\n\nrgx_cep = Regex(\n    digits.quantifier(5),\n    Regex(\"-\").quantifier(0, 1),\n    digits.quantifier(3),\n)  from mre import Regex, Quantifier, Set\nfrom mre.helper import Range\n\n# Todos os d\u00edgitos [0-9]\ndigits = Set(Range().digits())\n# O h\u00edfen pode aparecer nenhuma ou uma vez\nhyphen = Quantifier(\"-\", 0, 1)\n\nrgx_cep = Regex(\n    digits.quantifier(5), hyphen,\n    digits.quantifier(3),\n)  RegEx de  CPF  ( [0-9]{3}.?[0-9]{3}.?[0-9]{3}-?[0-9]{2} ):  from mre import Regex, Set\nfrom mre.helper import Range\n\n# Todos os d\u00edgitos\nall_digits = Set(Range(0, 9))\n# O ponto pode aparecer nenhuma ou uma vez\ndot = Regex(Regex.DOT).quantifier(0, 1)\n# O h\u00edfen pode aparecer nenhuma ou uma vez\nhyphen = Regex('-').quantifier(0, 1)\n\nrgx_cpf = Regex(\n    all_digits.quantifier(3), dot,\n    all_digits.quantifier(3), dot,\n    all_digits.quantifier(3), hyphen,\n    all_digits.quantifier(2),\n)  RegEx de  CNPJ  ( \\d{2}\\.?\\d{3}\\.?\\d{3}\\/?\\d{4}\\-?\\d{2} ):  from mre import Regex, Quantifier\n\n# Todos os d\u00edgitos\ndigits = Regex(Regex.DIGIT)\n# O ponto pode aparecer nenhuma ou uma vez\ndot = Regex(Regex.DOT).quantifier(0, 1)\n# A barra pode aparecer nenhuma ou uma vez\nslash = Regex(Regex.SLASH).quantifier(0, 1)\n# O h\u00edfen pode aparecer nenhuma ou uma vez\nhyphen = Quantifier(\"-\", 0, 1)\n\nrgx_cnpj = Regex(\n    digits.quantifier(2), dot,\n    digits.quantifier(3), dot,\n    digits.quantifier(3), slash,\n    digits.quantifier(4), hyphen,\n    digits.quantifier(2),\n)",
            "title": "Exemplos"
        },
        {
            "location": "/pt_BR/",
            "text": "MRE\n\n\nUm pacote em Python para fazer express\u00e3o regular (RegEx). Possui o objetivo de transformar a cria\u00e7\u00e3o de um RegEx em algo mais f\u00e1cil de se ler.\n\n\nInstala\u00e7\u00e3o do MRE\n\n\nInstalando o pacote MRE usando o pip:\n\n\npip install mre",
            "title": "Home"
        },
        {
            "location": "/pt_BR/#mre",
            "text": "Um pacote em Python para fazer express\u00e3o regular (RegEx). Possui o objetivo de transformar a cria\u00e7\u00e3o de um RegEx em algo mais f\u00e1cil de se ler.",
            "title": "MRE"
        },
        {
            "location": "/pt_BR/#instalacao-do-mre",
            "text": "Instalando o pacote MRE usando o pip:  pip install mre",
            "title": "Instala\u00e7\u00e3o do MRE"
        }
    ]
}